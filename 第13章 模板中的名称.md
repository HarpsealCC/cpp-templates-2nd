# 第13章 模板中的名称
在大多数编程语言中，名称是一个基本的概念。程序员可以通过名称来引用到此前构造出的实体。当C++编译器遇到名称时，它必须通过查找过程以标识其所引用的实体。从实现者角度来看，C++在这方面颇为困难。考虑C++语句`x * y;`，如果`x`和`y`都是变量的名称，这一语句就是一个乘法表达式，但是如果`x`是类型的名称，则语句就是声明了一个`y`变量实体，其类型是`x`类型的指针。

这一小小的例子阐释了C++（类C）是一门上下文敏感型语言(context-sensitive language)：在不了解更宽泛上下文时一个结构无法一直被理解。这与模板有什么关联呢？其实，模板也是结构，它们也必须与多重宽泛的上下文打交道：（1）模板所在的上下文，（2）模板实例化的上下文，以及（3）用于模板实体化的模板实参所关联的上下文。因此，在C++中“名称”需要被小心的处理就不足为奇了。

## 13.1 名称分类
C++对名称的分类有非常非常多的方式。为了应付这一术语的丰富性，我们提供了表13.1和表13.2，对这些分类进行了描述。幸运的是，熟悉下面两种主要的命名理念就可以对C++模板话题有一个良好的视角：
1. 如果名称的作用域被显式地使用域操作符（`::`）或是成员访问操作符(`.`或`->`)指定，则它是一个限定名称(qualified name)。例如，`this->count`是一个限定名称，但是`count`本身不是（尽管字面上`count`实际上指代的是一个类成员）。
2. 如果名字在某种方式上依赖于一个模板参数，那么该名称就是一个依赖型名称(dependent name)。例如，当`T`是一个模板参数时，`std::vector<T>::iterator`是一个依赖型名称，但是当`T`是一个已知的类型别名时（比如`using T = int` ），它就变成了一个非依赖型名称。

| 分类 | 解释和说明 |
| - | - |
| 标识符 | 仅由不间断的字母、下划线和数字组成的名称。不能以数字开头，并且某些标识符是被保留的：你不能在应用程序引入它们（根据经验，请避免使用下划线和双下划线开头）。字母这一概念较为宽泛，包含了特殊的通用字符名称(UCNs)，通过非字母语言编码成形 |
| 操作符函数id | 关键字operator跟着的符号，作为一个操作符——例如，`operator new`和`operator []`。|
| 转换函数id | 用于表示一个用户定义的隐式转换操作符——例如，`operator int&`，这经常与`int`二进制与混淆。 |
| 字面操作符id | 用于表示一个用户定义的字面操作符——例如，`operator ""_km`，可以用来书写字面值`100_km`(C++11中引入) |
| 模板id | 模板实参后闭合的尖括号子句内模板名称；例如，`List<T, int, 0>`。模板id也可以是一个闭合尖括号子句内的模板实参前的操作符函数id或一个字面操作符id；例如，`operator+<X<int>>。`|
| 非限定id | 标识符的泛化形式。可以是上述的任何一种（标识符、操作符函数id、转换函数id、字面操作符id或是模板id），也可以是一个“析构器名称”（例如，记如`~Data`或是`~List<T, T, N>`）。 |
| 限定id | 对非限定id使用类、枚举、命名空间的名称或是仅仅只是使用全局作用域操作符限定就是一个限定id。请注意这样的名称本身也可以被限定。例如`::X`，`S::x`，`Array<T>::y`和`::N::A<T>::z`。 |
| 限定名称 | 标准中并没有定义这一术语，但是我们一般用它来代表经过限定查找的名称。具体来说，这是在显式成员访问操作符（`.`或`->`）之后使用的限定id或非限定id。例如`S::x`,`this->f`和`p->A::m`。然而，上下文中隐式等价于`this->class_mem`的`class_mem`并不是一个限定名称：成员访问必须是显式的。|
| 非限定名称 | 非限定id并不是限定名称。这并非标准中的术语，对应于经过标准所称谓的非限定查找的名称。 |
| 名称 | 限定或非限定名称 |
<center>表13.1 名称分类（第一部分）</center>

| 分类 | 解释和说明 |
| - | - |
| 依赖型名称 | 通过某种方式依赖于模板参数的名称。一般来说，一个显式地包含所依赖的模板参数的限定或非限定名称就是一个依赖型名称。此外，如果成员访问运算符（`.`或`->`）左侧的表达式与类型相关，则通常由其限定的限定名称是一个依赖型名称，这一概念在P223节13.3.6中进行了讨论。特别地，`this->b`中的`b`当其出现在模板中时，通常是依赖型名称。最后，取决于参数依赖查找的名称，诸如函数调用`ident(x, y)`中的`ident`或是表达式`x+y`中的`+`，当且仅当参数表达式中任意一个是类型依赖的，那么其就是一个依赖型名称。 |
| 非依赖型名称 | 不满足上述描述中“依赖型名称”的名称即是一个非依赖型名称 |
<center>表13.2 名称分类（第二部分）</center>

通读该表会更加熟悉C++模板话题中的这些术语，但是也没有必要去记住每个术语的精准含义。什么时候需要，就什么时候通过索引来查阅。

## 13.2 名称查找


