# 第13章 模板中的名称
在大多数编程语言中，名称是一个基本的概念。借助名称，程序员可以引用前面已经构造完毕的实体。当C++编译器遇到一个名称时，它会查找该名称，来确认它所引用的是哪个实体。从实现者角度来看，就名称而言，C++在这方面相当棘手。譬如C++语句`x * y;`，如果`x`和`y`都是变量的名称，那么这一语句就是一个乘法表达式，但是如果`x`是类型的名称，则语句就是声明了一个`y`变量实体，其类型是`x`类型实体的指针。

这一小小的例子阐释了C++（类C）是一门上下文相关语言(context-sensitive language)：对于C++的一个结构，我们无法脱离上下文来理解它。而这又与模板有什么关联呢？事实上，模板也是一种结构，它也必须处理多种上下文相关信息：（1）模板出现的上下文；（2）模板实例化的上下文；（3）用于模板实例化的模板实参的上下文。因此，在C++中，“名称”需要被小心的处理这一事实就不足为奇了。

## 13.1 名称的分类
C++对名称的分类有多种多样的方式。为了理解名称的众多术语，我们提供了表13.1和表13.2，对这些分类进行了描述。幸运的是，熟悉下面两种主要的命名概念，就可以深入理解大多数的C++模板话题：
1. 如果名称的作用域由域操作符（`::`）或是成员访问操作符(`.`或`->`)显式指定，我们就称该名称为受限名称(qualified name)。例如，`this->count`是一个受限名称，但是`count`本身则不是（尽管字面上`count`实际上指代的也是一个类成员）。
2. 如果一个名称以某种方式依赖于模板参数，那么该名称就是一个依赖型名称(dependent name)。例如，当`T`是一个模板参数时，`std::vector<T>::iterator`是一个依赖型名称；但如果`T`是一个已知的类型别名时（比如`using T = int` ），那么`std::vector<T>::iterator`就不是一个依赖型名称。

| 分类 | 解释和说明 |
| - | - |
| 标识符(Identifier) | 仅由不间断的字母、下划线和数字组成的名称。不能以数字开头，并且某些标识符是被保留的：你不能在应用程序中引入它们（有个潜规则：请避免使用下划线和双下划线开头）。字母这一概念较为宽泛，它还包含了通用字符名称(Universal Character Name, UCN)，UCN通过非字符的编码格式存储信息 |
| 操作符函数id(Operator-function-id) | 关键字`operator`后紧跟的操作符符号。例如，`operator new`和`operator []`。|
| 类型转换函数id(Conversion-function-id) | 用于表示一个用户定义的隐式类型转换操作符。例如，`operator int&`，也可以写作`operator int bitand`（迷惑行为）。 |
| 字面操作符id(Literal-operator-id) | 用于表示一个用户定义的字面操作符——例如，`operator ""_km`，可以用来书写字面值`100_km`(C++11中引入) |
| 模板id(Template-id) |由闭合的尖括号子句内的模板实参构成的模板名称。例如，`List<T, int, 0>`。模板实参所在的闭合尖括号前面的操作符函数id或一个字面操作符id也可以是一个模板id。例如，`operator+<X<int>>。`|
| 非受限id(Unqualified-id) | 广义的标识符。可以是上述的任何一种（标识符、操作符函数id、类型转换函数id、字面操作符id或是模板id），也可以是一个“析构器名称”（例如，记如`~Data`或是`~List<T, T, N>`）。 |
| 受限id(Qualified-id) | 对非受限id使用类、枚举、命名空间的名称做限定或是仅仅使用全局作用域操作符做限定，得到的就是一个受限id。显然这种名称本身也可以是多次受限的。例如`::X`，`S::x`，`Array<T>::y`和`::N::A<T>::z`。 |
| 受限名称(Qualified-name) | 标准中并没有定义这一概念，但是我们一般用它来表示经过受限查找的名称。具体来说，它是一个受限id或是一个在前面显式使用了成员访问操作符（`.`或`->`）的非受限id。例如`S::x`,`this->f`和`p->A::m`。然而，上下文中隐式等价于`this->class_mem`的`class_mem`并不是一个受限名称：成员访问必须是显式的。|
| 非受限名称(Unqualified-name) | 除受限名称以外的非受限id。这并非标准中的概念，我们只是用它来表示调用非受限查找时引用的名称。 |
| 名称(Name) | 一个受限或非受限名称 |
<center>表13.1 名称分类（第一部分）</center>

| 分类 | 解释和说明 |
| - | - |
| 依赖型名称(Dependent name) | 通过某种方式依赖于模板参数的名称。一般来说，显式包含模板参数的受限名称或非受限名称都是依赖型名称。此外，如果成员访问运算符（`.`或`->`）左侧的表达式与类型相关，则通常由其限定的受限名称也是一个依赖型名称，这一概念在P223节13.3.6中进行了讨论。特别地，`this->b`中的`b`当其出现在模板中时，通常是依赖型名称。最后，取决于参数依赖查找的名称，诸如函数调用`ident(x, y)`中的`ident`或是表达式`x+y`中的`+`，当且仅当参数表达式中任意一个是类型依赖的，那么其就是一个依赖型名称。 |
| 非依赖型名称(Nondependent name) | 不满足上述描述中“依赖型名称”的名称即是一个非依赖型名称 |
<center>表13.2 名称分类（第二部分）</center>

通读该表会更加熟悉C++模板话题中的这些概念，但是也没有必要去记住每个定义的精准含义。什么时候需要，就什么时候通过索引来查阅。

## 13.2 名称查找
在C++中，名称查找有非常多的小细节，但是我们这里只关注一些主要概念。只有在下面两种情景中我们才有必要确认名称查找的细节：（1）按直观处理会犯错的普通例子（2）C++标准给出的错误例子。

受限名称的查找是在一个受限作用域内进行的，该受限作用域由限定的结构所决定。如果作用域是一个类，那么查找范围可以到达其基类，但不会考虑外围作用域(enclosing scopes)。下面的例子阐释了这一基本原则：

```cpp
int x;

class B {
  public:
    int i;
};

class D: public B {
};

void f(D* pd)
{
  pd->i = 3;	// finds B::i
  D::x = 2;		// ERROR: does not find ::x in the enclosing scope
}
```

非受限名称的查找则恰恰相反，它可以(由内到外)在所有外围类中逐层地进行查找（但在某个类内部定义的成员函数定义中，它会优先查找该类和基类的作用域，然后才查找外围类的作用域），这种查找方式被称为普通查找(ordinary lookup)。下面是一个用于理解普通查找的基本示例：

```cpp
extern int count;				// #1
int lookup_example(int count)	// #2
{
	if (count < 0) {
		int count = 1;			// #3
		lookup_example(count);	// unqualified count refers to #3
	}
	return count + ::count;		// the first (unqualified) count refers to #2;
								// the second (qualified) count refers to #1
}
```

对于非受限名称的查找，最近增加了一项新的查找机制——除了普通查找外——有时还会进行参数依赖查找(argument-dependent lookup, ADL)。在展开叙述ADL之前，我们先用前面的`max()`模板来说明这一机制的动机：

```cpp
template<typename T>
T max(T a, T b)
{
  return b < a ? a : b;
}
```

假设当前我们需要让“另一个命名空间的类型”来使用这一模板：

```cpp
namespace BigMath {
  class BigNumber {
    ...
  };
  
  bool operator < (BigNumber const &, BigNumber const &);
  ...
}

using BigMath::BigNumber;

void g(BigNumber const& a, BigNumber const& b)
{
  ...
  BigNumber x = ::max(a,b);
  ...
}
```

这里的问题在于`max()`模板不认识`BigMath`命名空间，普通查找无法找到类型`BigNumber`适用的`operator <`。如果没有特殊规则的话，这种限制大大降低了C++命名空间中模板的应用性。而ADL正是这个“特殊规则”，也正是解决这种限制的关键之处。

### 13.2.1 ADL
ADL主要应用于非限定名称，这些名词看起来像是函数调用或操作符调用中的非成员函数。如果普通查找找到了以下内容，ADL不会发生：
- 成员函数名称
- 变量名称
- 类型名称
- 块作用域函数声明名称

如果把被调用函数的名称用圆括号括起来，ADL也会被禁用。

否则，如果名称后的括号里面有实参表达式列表，则ADL将会查找这些实参“关联”的命名空间和类。对这些关联的命名空间(associated namespace)和关联类(associated class)的精准定义会在后文给出，但在直觉上它们可以被认为是与给定类型相关联的所有命名空间和类。例如，如果某一类型是一个`class X`的指针，那么关联的类和命名空间就包括`X`和`X`所属的任何命名空间或类。

对给定类型，关联命名空间和关联类所组成的集合的精准定义，我们可以通过下列规则来确定：
- 对内置类型，该集合为空集。
- 对指针和数组类型，该集合就是其底层所引用类型的关联类和关联命名空间。
- 对枚举类型，关联命名空间就是枚举声明所在的命名空间。
- 对类成员，关联类就是其所在的类。
- 对类类型（包括联合体类型），关联类集合包括其类型本身、它的外围类型、所有的直接或间接基类。关联命名空间集合是每个关联类所在的命名空间。如果类是一个类模板实例，那么类模板实参的类型以及声明模板的模板实参所在的类和命名空间也将包含在内。
- 对函数类型，关联命名空间和类的集合包含每一个参数类型和返回值所关联的命名空间和类。
- 对指向类`X`的成员指针类型，关联的命名空间和类包括`X`以及成员类型本身的关联。（如果是指向成员函数的类型，那么参数和返回类型也算数。）
至此，ADL会在所有的关联命名空间和关联类中依次地查找，就好像依次地直接使用这些命名空间进行限定一样。唯一的例外情况是：它会忽略`using`指示符(using-directives)。下面的例子说明了这一点：

*details/adl.cpp*
```cpp
#include <iostream>

namespace X {
  template<typename T> void f(T);
}

namespace N {
  using namespace X;
  enum E { e1 };
  void f(E) {
    std::cout << "N::f(N::E) called\n";
  }
}

void f(int)
{
  std::cout << "::f(int) called\n";
}

int main()
{
  ::f(N::e1);	// qualified function name: no ADL
  f(N::e1);		// ordinary lookup finds ::f() and ADL finds N::f(),
  				// the latter is preferred
}
```

我们可以看出：在这个例子中，当执行ADL时，命名空间`N`中的`using-directive`被忽略了。因此，在这个`main()`函数内部的调用中，`X::f()`甚至永远都无法作为一个候选者。

### 13.2.2 友元声明的ADL查找