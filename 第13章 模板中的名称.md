# 第13章 模板中的名称
在大多数编程语言中，名称是一个基本的概念。借助名称，程序员可以引用前面已经构造完毕的实体。当C++编译器遇到一个名称时，它会查找该名称，来确认它所引用的是哪个实体。从实现者角度来看，就名称而言，C++在这方面相当棘手。譬如C++语句`x * y;`，如果`x`和`y`都是变量的名称，那么这一语句就是一个乘法表达式，但是如果`x`是类型的名称，则语句就是声明了一个`y`变量实体，其类型是`x`类型实体的指针。

这一小小的例子阐释了C++（类C）是一门上下文相关语言(context-sensitive language)：对于C++的一个结构，我们无法脱离上下文来理解它。而这又与模板有什么关联呢？事实上，模板也是一种结构，它也必须处理多种上下文相关信息：（1）模板出现的上下文；（2）模板实例化的上下文；（3）用于模板实例化的模板实参的上下文。因此，在C++中，“名称”需要被小心的处理这一事实就不足为奇了。

## 13.1 名称的分类
C++对名称的分类有多种多样的方式。为了理解名称的众多术语，我们提供了表13.1和表13.2，对这些分类进行了描述。幸运的是，熟悉下面两种主要的命名概念，就可以深入理解大多数的C++模板话题：
1. 如果名称的作用域由域操作符（`::`）或是成员访问操作符(`.`或`->`)显式指定，我们就称该名称为受限名称(qualified name)。例如，`this->count`是一个受限名称，但是`count`本身则不是（尽管字面上`count`实际上指代的也是一个类成员）。
2. 如果一个名称以某种方式依赖于模板参数，那么该名称就是一个依赖型名称(dependent name)。例如，当`T`是一个模板参数时，`std::vector<T>::iterator`是一个依赖型名称；但如果`T`是一个已知的类型别名时（比如`using T = int` ），那么`std::vector<T>::iterator`就不是一个依赖型名称。

| 分类 | 解释和说明 |
| - | - |
| 标识符(Identifier) | 仅由不间断的字母、下划线和数字组成的名称。不能以数字开头，并且某些标识符是被保留的：你不能在应用程序中引入它们（有个潜规则：请避免使用下划线和双下划线开头）。字母这一概念较为宽泛，它还包含了通用字符名称(Universal Character Name, UCN)，UCN通过非字符的编码格式存储信息 |
| 操作符函数id(Operator-function-id) | 关键字`operator`后紧跟的操作符符号。例如，`operator new`和`operator []`。|
| 类型转换函数id(Conversion-function-id) | 用于表示一个用户定义的隐式类型转换操作符。例如，`operator int&`，也可以写作`operator int bitand`（迷惑行为）。 |
| 字面操作符id(Literal-operator-id) | 用于表示一个用户定义的字面操作符——例如，`operator ""_km`，可以用来书写字面值`100_km`(C++11中引入) |
| 模板id(Template-id) |由闭合的尖括号子句内的模板实参构成的模板名称。例如，`List<T, int, 0>`。模板实参所在的闭合尖括号前面的操作符函数id或一个字面操作符id也可以是一个模板id。例如，`operator+<X<int>>。`|
| 非受限id(Unqualified-id) | 广义的标识符。可以是上述的任何一种（标识符、操作符函数id、类型转换函数id、字面操作符id或是模板id），也可以是一个“析构器名称”（例如，记如`~Data`或是`~List<T, T, N>`）。 |
| 受限id(Qualified-id) | 对非受限id使用类、枚举、命名空间的名称做限定或是仅仅使用全局作用域操作符做限定，得到的就是一个受限id。显然这种名称本身也可以是多次受限的。例如`::X`，`S::x`，`Array<T>::y`和`::N::A<T>::z`。 |
| 受限名称(Qualified-name) | 标准中并没有定义这一概念，但是我们一般用它来表示经过受限查找的名称。具体来说，它是一个受限id或是一个在前面显式使用了成员访问操作符（`.`或`->`）的非受限id。例如`S::x`,`this->f`和`p->A::m`。然而，上下文中隐式等价于`this->class_mem`的`class_mem`并不是一个受限名称：成员访问必须是显式的。|
| 非受限名称(Unqualified-name) | 除受限名称以外的非受限id。这并非标准中的概念，我们只是用它来表示调用非受限查找时引用的名称。 |
| 名称(Name) | 一个受限或非受限名称 |
<center>表13.1 名称分类（第一部分）</center>

| 分类 | 解释和说明 |
| - | - |
| 依赖型名称(Dependent name) | 通过某种方式依赖于模板参数的名称。一般来说，显式包含模板参数的受限名称或非受限名称都是依赖型名称。此外，如果成员访问运算符（`.`或`->`）左侧的表达式与类型相关，则通常由其限定的受限名称也是一个依赖型名称，这一概念在P223节13.3.6中进行了讨论。特别地，`this->b`中的`b`当其出现在模板中时，通常是依赖型名称。最后，取决于参数依赖查找的名称，诸如函数调用`ident(x, y)`中的`ident`或是表达式`x+y`中的`+`，当且仅当参数表达式中任意一个是类型依赖的，那么其就是一个依赖型名称。 |
| 非依赖型名称(Nondependent name) | 不满足上述描述中“依赖型名称”的名称即是一个非依赖型名称 |
<center>表13.2 名称分类（第二部分）</center>

通读该表会更加熟悉C++模板话题中的这些概念，但是也没有必要去记住每个定义的精准含义。什么时候需要，就什么时候通过索引来查阅。

## 13.2 名称查找
在C++中，名称查找有非常多的小细节，但是我们这里只关注一些主要概念。只有在下面两种情景中我们才有必要确认名称查找的细节：（1）按直观处理会犯错的普通例子（2）C++标准给出的错误例子。

受限名称的查找是在一个受限作用域内进行的，该受限作用域由限定的结构所决定。如果作用域是一个类，那么查找范围可以到达其基类，但不会考虑外围作用域(enclosing scopes)。下面的例子阐释了这一基本原则：

```cpp
int x;

class B {
  public:
    int i;
};

class D: public B {
};

void f(D* pd)
{
  pd->i = 3;	// finds B::i
  D::x = 2;		// ERROR: does not find ::x in the enclosing scope
}
```

非受限名称的查找则恰恰相反，它可以(由内到外)在所有外围类中逐层地进行查找（但在某个类内部定义的成员函数定义中，它会优先查找该类和基类的作用域，然后才查找外围类的作用域），这种查找方式被称为普通查找(ordinary lookup)。下面是一个用于理解普通查找的基本示例：

```cpp
extern int count;				// #1
int lookup_example(int count)	// #2
{
	if (count < 0) {
		int count = 1;			// #3
		lookup_example(count);	// unqualified count refers to #3
	}
	return count + ::count;		// the first (unqualified) count refers to #2;
								// the second (qualified) count refers to #1
}
```

对于非受限名称的查找，最近增加了一项新的查找机制——除了普通查找外——有时还会进行参数依赖查找(argument-dependent lookup, ADL)。在展开叙述ADL之前，我们先用前面的`max()`模板来说明这一机制的动机：

```cpp
template<typename T>
T max(T a, T b)
{
  return b < a ? a : b;
}
```

假设当前我们需要让“另一个命名空间的类型”来使用这一模板：

```cpp
namespace BigMath {
  class BigNumber {
    ...
  };
  
  bool operator < (BigNumber const &, BigNumber const &);
  ...
}

using BigMath::BigNumber;

void g(BigNumber const& a, BigNumber const& b)
{
  ...
  BigNumber x = ::max(a,b);
  ...
}
```

这里的问题在于`max()`模板不认识`BigMath`命名空间，普通查找无法找到类型`BigNumber`适用的`operator <`。如果没有特殊规则的话，这种限制大大降低了C++命名空间中模板的应用性。而ADL正是这个“特殊规则”，也正是解决这种限制的关键之处。

### 13.2.1 ADL
ADL主要应用于非限定名称，这些名词看起来像是函数调用或操作符调用中的非成员函数。如果普通查找找到了以下内容，ADL不会发生：
- 成员函数名称
- 变量名称
- 类型名称
- 块作用域函数声明名称

如果把被调用函数的名称用圆括号括起来，ADL也会被禁用。

否则，如果名称后的括号里面有实参表达式列表，则ADL将会查找这些实参“关联”的命名空间和类。对这些关联的命名空间(associated namespace)和关联类(associated class)的精准定义会在后文给出，但在直觉上它们可以被认为是与给定类型相关联的所有命名空间和类。例如，如果某一类型是一个`class X`的指针，那么关联的类和命名空间就包括`X`和`X`所属的任何命名空间或类。

对给定类型，关联命名空间和关联类所组成的集合的精准定义，我们可以通过下列规则来确定：
- 对内置类型，该集合为空集。
- 对指针和数组类型，该集合就是其底层所引用类型的关联类和关联命名空间。
- 对枚举类型，关联命名空间就是枚举声明所在的命名空间。
- 对类成员，关联类就是其所在的类。
- 对类类型（包括联合体类型），关联类集合包括其类型本身、它的外围类型、所有的直接或间接基类。关联命名空间集合是每个关联类所在的命名空间。如果类是一个类模板实例，那么类模板实参的类型以及声明模板的模板实参所在的类和命名空间也将包含在内。
- 对函数类型，关联命名空间和类的集合包含每一个参数类型和返回值所关联的命名空间和类。
- 对指向类`X`的成员指针类型，关联的命名空间和类包括`X`以及成员类型本身的关联。（如果是指向成员函数的类型，那么参数和返回类型也算数。）
至此，ADL会在所有的关联命名空间和关联类中依次地查找，就好像依次地直接使用这些命名空间进行限定一样。唯一的例外情况是：它会忽略`using`指示符(using-directives)。下面的例子说明了这一点：

*details/adl.cpp*
```cpp
#include <iostream>

namespace X {
  template<typename T> void f(T);
}

namespace N {
  using namespace X;
  enum E { e1 };
  void f(E) {
    std::cout << "N::f(N::E) called\n";
  }
}

void f(int)
{
  std::cout << "::f(int) called\n";
}

int main()
{
  ::f(N::e1);	// qualified function name: no ADL
  f(N::e1);		// ordinary lookup finds ::f() and ADL finds N::f(),
  				// the latter is preferred
}
```

我们可以看出：在这个例子中，当执行ADL时，命名空间`N`中的`using-directive`被忽略了。因此，在这个`main()`函数内部的调用中，`X::f()`甚至永远都无法作为一个候选者。

### 13.2.2 友元声明的ADL
在类中友元函数的声明可以是该友元函数的首次声明。在此场景中，对于包含这个友元函数的类，假设它所属的最近的命名空间作用域（可能是全局作用域）为作用域A，我们就可以认为该友元函数是在作用域A中声明的。然而，这样的友元声明在该作用域中并不是直接可见的。考虑下面的例子：

```cpp
template<typename T>
class C {
  ...
  friend void f();
  friend void f(C<T> const&);
  ...
};

void g(C<int>* p) {
  f();		// is f() visible here?
  f(*p);	// is f(C<int> const&) visible here?
}
```

如果友元声明在外围命名空间中可见，那么实例化一个类模板可能会使一些普通函数的声明也变为可见的（比如
f()）。这可能会产生一些令人惊讶的行为：函数调用`f()`会导致编译错误，除非类C的实例在程序更早的地方出现过！

另一方面，仅仅通过友元函数声明（并定义）一个函数非常有用（参考P497节21.2.1依赖于这种行为的某个技巧）。当友元函数所在的类属于ADL查找过程的关联类时，该友元函数就是可见的。

再次考虑上面的例子，`f()`没有关联类或关联命名空间，因为它并没有任何参数：在这个例子中该调用是无效的。然而，`f(*p)`调用有着关联类`C<int>`（因为它是`*p`的类型），并且全局命名空间也是关联的（因为这是`*p`的类型声明所在的命名空间）。因此，只要我们在调用之前完全实例化`class C<int>`，就可以找到第二个友元函数。为了确保这一点，我们可以假设：对于涉及在关联类中友元查找的调用，实际上会导致该（关联）类被实例化（如果还没有实例化的话）。

ADL查找友元声明和定义的能力有时候也被称为友元名称注入(friend name injection)。然而，这一术语有些误导性，因为它是一个前标准C++特性的名称，该特性会确实地把友元声明的名称“注入”到外围作用域中，使得它们在普通名称查找中可见。对于我们的上例，这意味着两个调用都是有效的。本章的后续内容会详述友元名称注入的历史。

### 13.2.3 注入式类名称
如果在类本身的作用域中注入该类的名称，我们就称该名称为注入式类名称。它可以被看作位于该类作用域中的一个非受限名称，而且是可访问的名称（然而，作为受限名称时是不可访问的，因为此时该名称用于表示构造器）。例如下面的例子：

*details/inject.cpp*
```cpp
#include <iostream>

int C;
class C {
  private:
    int i[2];
  public:
    static int f() {
	  return sizeof(C);
	}
};

int f() 
{
  return sizeof(C);
}

int main()
{
  std::cout << "C::f() = " << C::f() << ','
  			<< " ::f() = " << ::f() << '\n';
}
```

成员函数`C::f()`返回了类型`C`的尺寸，而`::f()`则返回了变量`C`的尺寸（换句话说，`int`对象的尺寸）。

类模板也可以有注入式类名称。然而，相比较普通的注入式类名称来说，它们有些区别：它们的后面可以紧跟模板实参（此种场景中，它们也被称为注入式类模板名称）。但是，如果后面没有紧跟模板实参，那么它们代表的就是用参数来代表实参的类（例如，对于偏特化，还可以用特化实参代表对应的模板实参）。这解释了下面的情景：

```cpp
template<template<typename> class TT> class X {
};

template<typename T> class C {
  C* a;			// OK: same as "C<T>* a;"
  C<void>& b;	// OK
  X<C> c;		// OK: C without a template argument list denotes the template C
  X<::C> d;		// OK: ::C is not the injected class name and therefore always
  				// 		denotes the template
};
```

注意看非受限名称是如何引用注入式名称的，并且，如果名称后没有跟随模板实参列表的话，它们不会被认作模板名称。为了补偿，我们可以在模板名称前强制使用`::`限定符。

可变模板的注入式类名称还有一个额外的特点：如果注入式类名称是通过使用可变模板的模板参数直接组成的，那么注入式类名称也将包含尚未展开的模板参数包（参考P201节12.4.1了解包展开的细节）。因此，当为可变模板组织注入式类名称时，对应于模板参数包的模板实参是一个包展开，它的模式就是模板参数包：

```cpp
template<int I, typename... T> class V {
  V* a;			// OK: same as "V<I, T...>* a;"
  V<0, void> b;	// OK
};
```

### 13.2.4 当前实例
类或类模板的注入式类名称实际上是类型定义的一个别名。对非模板类来说，这一特性是显然的，因为类本身就是其作用域内其名称的唯一类型。然而，在类模板或是类模板嵌套的类中，每个模板实例都会产生一个不同的类型。在这一上下文中，该特性就非常有趣了，因为这意味着注入式类名称指向类模板的同一个实例而不是类模板的某些其他实例（对类模板的嵌套类来说也一样）。

在类模板中，类或类模板范围内的注入式类名称或是其他等价于注入式类名称的类型（包括类型别名的声明）都被称为一个当前实例(current instantiation)。依赖于模板参数但并不指代一个当前实例的类型被称为一个未知的特化(unknown specialization)，它可以从相同的类模板或某些全然不同的类模板实例化。下面的例子阐释了这一区别：

```cpp
template<typename T> class Node {
  using Type = T;	
  Node* next;			// Node refers to a current instantiation
  Node<Type>* previous;	// Node<Type> refers to a current instantiation
  Node<T*>* parent;		// Node<T*> refers to an unknown specialization  
};
```

在嵌套类和类模板中辨别某个类型是否指代一个当前实例往往扑朔迷离。类和类模板范围内的注入式类名称（或者等价于它们的类型）是一个当前实例，而其他嵌套的类或类模板中的名称则不是一个当前实例：

```cpp
template<typename T> class C {
  using Type = T;
  
  struct I {
    C* c;			// C refers to a current instantiation
	C<Type>* c2;	// C<Type> refers to a current instantiation
	I* i;			// I refers to a current instantiation
  };
  
  struct J {
    C* c;			// C refers to a current Instantiation
	C<Type>* c2;	// C<Type> refers to a current instantiation
	I* i;			// I refers to an unknown specialization,
					// because I does not enclose
	J* j;			// J refers to a current instantiation
  };
};
```

当类型指代的是一个当前实例时，实例化的类的内容可以保证是由当前定义的类模板或嵌套类所实例化的。当解析模板（下一节的主题）时这对名称查找有着意义，但与此同时它也引导了另一种方案，一种更像游戏的方式来决定类模板中的类型`X`的定义指代的是一个当前实例还是一个未知的特化：如果另一个程序员可以写出一个显式特化（在第16章描述细节）使得`X`指向该特化体，那么`X`就指代一个未知的特化。例如，考虑上例上下文中类型`C<int>::J`的实例：我们知道`C<T>::J`的定义用于实例化特定的具体类型（也就是我们所实例化的类型）。此外，由于显式特化无法在不同时特化范围内所有模板或成员的情况下，特化某一个模板或模板成员，`C<int>`会在类定义范围内被实例化。因此，`J`和`C<int>`的引用在J所在范围内均指代一个当前实例。而另一方面，我们可以写出一个`C<int>::I`的显式特化，如下文：

```cpp
template<> struct C<int>::I {
  // definition of the specialization
};
```

这里，`C<int>::I`的特化提供了一个与`C<T>::J`所可见的定义完全不同的定义，因此定义`C<T>::J`中定义的`I`指代的是一个未知的特化。

## 13.3 解析模板
大多数程序设计语言的编译都包含两个最基本的步骤——符号标记（也称作扫描或词法解析）和（语法）解析。符号标记过程会按字符顺序读取源代码，然后生成一个符号序列。例如，当看到字符序列`int* p = 0;`时，扫描器会为关键字`int`、符号/操作符`*`、标识符`p`、符号/操作符`=`、整型字面量`0`和符号/操作符`;`生成符号。

解析器会递归地减少符号标记，或是把前面已经找到的模式结合成更高层次的结构。例如，符号`0`是一个合法的表达式，`*`后跟随的标识符`p`是一个合法的声明器(declarator)，该声明器后接`=`再接表达式`0`是一个合法的初始化声明器(init-declarator)。最终，关键字`int`是一个已知的类型名称，并且当后面跟着初始化声明器`*p = 0`时，你就得到了`p`的初始化声明。

### 13.3.1 非模板中的上下文相关性
你可能已经知道（或者期望）符号标记比解析简单得多。幸运的是，解析已经是一门理论发展得相当成熟的学科，使用这一理论对于理解大多数语言的解析都不算困难。然而，这一理论在上下文无关语言中表现最佳，而我们已经知道了C++是一门上下文相关语言。为此，C++编译器会使用一张符号表来把扫描器和解析器结合起来：当解析到一个声明时，会把它丢进符号表中。当扫描器找到一个标识符时，它会在符号表中进行查找，如果发现该标识符是一个类型时，就会注释所得的符号。

例如，如果C++编译器看到`x*`，扫描器会查找`x`。如果找到了一个类型，解析器会看到
```
identifier, type, x
symbol, *
```
并得出一个结论：从这里开始进行了一个声明。然而，如果没有找到类型`x`，那么解析器会接收到下面的符号：
```
identifier, nontype, x
symbol, *
```
此时该结构只能被合法解析成一个乘法表达式。这些原则的细节要依赖于编译器的具体实现策略，但大同小异。

另一个上下文相关的例子在下面的表达式中阐释：
```
X<1>(0)
```
如果`X`是类模板的名称，那么前面的表达式就是将整型`0`强制类型转换到类型`X<1>`（由该模板产生的）。如果`X`不是一个模板，那么上面的表达式等价于
```
(X<1)>0
```
换句话说，`X`会和1比较，然后根据结果——`true`或`false`，隐式转换成`1`或`0`——再与0进行比较。尽管这样的代码非常罕见，但它也是一个合法的C++代码（也是合法的C代码）。C++解析器会查找`<`前出现的名称，只有在该名称是一个模板名称时，才会把`<`看成是左尖括号；否则，`<`就被视为普通的小于操作符。

令人遗憾的是，这类上下文相关性都是由于选择尖括号来界定模板参数列表所造成的。下面是另一个例子：

```cpp
template<bool B>
class Invert {
  public:
    static bool const result = !B;
};

void g()
{
  bool test = Invert<(1>0)>::result;	// parentheses required!
}
```

如果`Invert<(1>0)>`的小括号被省略，大于等于符号就会被误认为是模板参数列表的闭合尖括号。这会使得代码无效，因为编译器会把它读作`((Invert<1>))0>::result`。

尖括号带给扫描器的问题还不止这些。例如，在语句：
```cpp
List<List<int>> a;
			//^-- no space between right angle brackets
```
两个`>`字符组合成了一个右移操作符`>>`，因此它们不再被视为两个独立的符号。这要归因于所谓的maximum munch tokenization原则：C++实现必须让一个符号拥有尽可能多的字符。

如P28节2.2所提及，在C++11之后，C++标准特别指出了这一情景——嵌套的模板id紧跟着右移符号`>>`——解析器会将模板id紧邻的右移符号视为两个独立的右尖括号`>`。有趣的是，此变更项会默默地更改某些程序（公认的程序）的含义。考虑下面的例子：

*names/anglebrackethack.cpp*
```cpp
#include <iostream>

template<int I> struct X {
  static int const c = 2;
};

template<> struct X<0> {
  typedef int c;
};

template<typename T> struct Y {
  static int const c = 3;
};

static int const c = 4;

int main()
{
  std::cout << (Y<X<1> >::c >::c>::c) << ' ';
  std::cout << (Y<X< 1>>::c >::c>::c) << '\n';
}
```

这是一个合法的C++98程序，输出`0 3`。它也是合法的C++11程序，但是尖括号变革使得括号内的两个语句是等价的，最终输出`0 0`。

由于`<:`是字符`[`的两字符替代(某些传统键盘是不支持的)，还有一个相似的问题存在，考虑下面的例子：

```cpp
template<typename T> struct G {};
struct S;
G<::S> gs;		// valid since C++11, but an error before that
```

C++11之前，最后一行代码等价于`G[:S>gs;`，这显然是不合法的。另一个词法hack技术被引入来解决该问题：当编译器看到字符序列`<::`没有紧跟着`:`或`>`时，前导`<:`字符对不再被视为`[`等价的两字符符号。这一两字符hack技术使得以前合法的程序变得不再合法：

```cpp
#define F(X) X ## :

int a[] = {1, 2, 3}, i = 1;
int n = a F(<::)i];		// valid in C++98/C++03, but not in C++11
```

想要理解它，就要注意到两字符hack应用于预处理符号，对预处理器来说变成了截然不同的符号，它们在宏展开完成前被决定。因此，C++98/C++03会无条件转换`<:`到`[`，因而定义展开成`int n = a[ :: i];`，显然这是没问题的。而C++11则不会进行字符转换，因为在宏展开前，序列`<::`没有跟随`:`或`>`而是`)`时，两字符转移不会进行，因此连接操作符`##`会试图连接`::`和`:`成为一个新的预处理符号`:::`，但显然这不是一个合法的符号。这一标准会导致未定义行为，也就意味着允许编译器做任何处理。某些编译器会诊断出这一问题，然而另一些则不会，它们会保持两个预处理符号分离，也就导致一个语法错误，因为它展开成对`n`的定义语句如下：
```cpp
int n = a < :: : i];
```

### 13.3.2 依赖型类型名称
模板中名称的问题在于它们无法始终被充分地分类。具体地，一个模板无法引用另一个模板的名称，因为其他模板的内容可能因显式特化而使原来的名称失效。下面的例子阐释了这一概念：

```cpp
template<typename T>
class Trap {
  public:
    enum { x };	// #1 x is not a type here
};

template<typename T>
class Victim {
  public:
    int y;
	void poof() {
	  Trap<T>::x * y;	// #2 declaration or multiplication?
	}
};

template<>
class Trap<void> {	// evil specialization!
  public:
    using x = int;	// #3 x is a type here
};

boid boom(Victim<void>& bomb)
{
  bomb.poof();
}
```

编译器解析行#2时，它必须确定这是一个声明语句还是一个乘法表达式。这一决定取决于依赖型受限名称`Trap<T>::x`是否是一个类型名称。编译器此时会尝试在模板`Trap`中查找，并且发现根据行#1，`Trap<T>::x`并不是一个类型，从而让我们相信行#2是一个乘法表达式。然而，在后面`T`取`void`的特化中，我们改写了（泛型的）`Trap<T>::X`，让它变成了一个类型，这完全违背了前面的源码。在特化场景中，`Trap<T>::x`实际上是一个`int`类型。

本例中，类型`Trap<T>`是一个依赖型类型，因为类型取决于模板参数`T`。此外，`Trap<T>`指代的是一个未知的特化（在P223节13.2.4中描述），这意味着编译器无法安全的在模板中查找以判定名称`Trap<T>::x`是否是一个类型。当`::`前的类型指代的是一个当前实例时——例如，`Victim<T>::y`——编译器才可以在模板定义中查找，这事因为它已经确定不会有其他的特化来干预。因此，如果`::`前的类型指代的是一个当前实例，那么模板中受限名称的查找与非依赖类型的受限名称查找表现得非常相似。

然而，如上例所阐释，未知的特化中的名称查找始终是一个问题。C++语言通过下面的规定来解决这个问题：通常而言，一个依赖型受限名称并不代表一个类型，除非在名字的前面加上了一个关键字`typename`前缀。对于类型而言，如果不加上`typename`前缀，那么在替换模板实参后，就不会被看成是一个类型名称，从而导致程序是无效的，你的C++编译器还会抱怨在实例化过程中出现了错误。另一方面，我们应该知道`typename`的这种用法和前面用于表示模板类型参数的用法是不同的：在这里你不能使用关键字`class`来等价替换`typename`。

总之，当类型名称具有以下性质时，就应该在名称前面添加`typename`前缀：
1. 名称是受限的，且本身没有后跟`::`组成一个更为受限的名称。
2. 名称不是详细类型说明符（elaborated-type-specifier）的一部分（例如，以`class`,`struct`,`union`,或`enum`起始的关键字）。
3. 名称不在指定基类继承的列表中，也不在引入构造函数的成员初始化列表中。
4. 名称依赖于模板参数。
5. 名称是某个未知的特化的成员，这意味着由限定器命名的类型指代一个未知的特化。

此外，除非至少满足前两个条件，才能使用`typename`前缀。为了阐释，考虑下面的错误示例：

```cpp
template<typename T>				// 1
struct S : typename X<T>::Base {	// 2
  S() : typename X<T>::Base(typename X<T>::Base(0)) {	// 3 4
  }
  
  typename X<T> f() {				// 5
    typename X<T>::C * p;			// declaration of pointer p	// 6
	X<T>::D *q;
  }
  
  typename X<int>::C *s;			// 7
  
  using Type = T;
  using OtherType = typename S<T>::Type;	// 8
}
```

每个出现的`typename`，不管正确与否，都被标了号。第一个`typename`表示一个模板参数。前面的规则没有应用于此。第二个和第三个`typename`由于上述规则的第三条而被禁止。这两个上下文中，基类的名称不能用`typename`引导。然而，第四个`typename`是必不可少的，因为这里基类的名称既不是位于初始化列表，也不是位于派生类的继承列表，而是为了基于实参`0`构造一个临时`X<T>::Base`表达式（也可以是某种强制类型转换）。第5个`typename`同样不合法，因为它后面的名称`X<T>`并不是一个受限名称。对于第6个`typename`，如果期望声明一个指针，那么这个`typename`是必不可少的。下一行省略了关键字`typename`，因此也就被编译器解释为一个乘法表达式。第7个`typename`是可选（可有可无）的，因为它符合前面的两条规则，但不符合后面的两条规则。第8个`typename`也是可选的，因为它指代的是一个当前实例的成员（也就不满足最后一条规则）。

最后一条判断`typename`前缀是否需要的规则有时候难以评估，因为它取决于判断类型所指代的是一个当前实例还是一个未知的特化这一事实。在这种场景中，最简单安全的方法就是直接添加`typename`关键字来指示受限名称是一个类型。`typename`关键字，尽管它是可选的，也会提供一个意图上的说明。

### 13.3.3 依赖型模板名称