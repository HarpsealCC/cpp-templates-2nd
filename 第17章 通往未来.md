# 第17章 通往未来

C++模板几乎一直在不断发展，从1988年的初始设计，到1998年、2011年、2014年和2017年的各种标准化里程碑。可以说，在原初的98标准之后，模板至少与大部分语言新增的主要功能有关联。

本书的第一版罗列了一些我们在首个标准之后可能会看到的扩展能力，这其中的一部分已经得以实现：
- 尖括号hack：C++11移除了需要在两个连续的尖括号之间插入一个空格的必要性
- 默认函数模板实参：C++11开始，函数模板参数可以具有默认实参
- Typedef模板：C++11引入了别名模板，具有类似的功能
- `typeof`操作符：C++11引入了`decltype`操作符，扮演了相同的角色（但是使用了一个不同的token来避免与已存在的扩展冲突，尽管该扩展并不满足C++开发者社区的需求）。
- 静态属性：第一版预测了编译器将直接支持某些type traits。事实上当前确实如此，尽管接口是使用标准库（然后使用若干traits的编译器扩展实现）来表达的。
- 个性实例化诊断：新的关键字`static_assert`实现了本书第一版所描述的`std::instantiation_error`的想法。
- 参数列表：在C++11中变成了参数包。
- 布局控制：C++11的`alignof`和`alignas`满足了本书第一版的需求。此外，C++17还新增了一个`std::variant`模板来支持union。
- 初始化器推导：C++17支持了类模板实参推导，算是同样的议题。
- 函数表达式：C++11的lambda表达式完整提供了这一功能（相比第一版的讨论使用了不一样的语法）。

第一版中其他方向的假设暂未收录到当前的语言规范，但其中的大部分目前仍在火热的讨论中，这里我们也对它们予以保留。与此同时，一些其他想法也在萌生，在此我们也会对其中的一部分想法进行表述。

## 17.1 宽容的`typename`法则

在本书的第一版中，在这一章节曾说过在未来可能会带来两种宽容的`typename`使用法则（228页节13.3.2）：允许在以前不允许的地方使用`typename`；当编译器可以相对轻松得推理出具有依赖型限定的限定名称指代的必定是某种类型时，可以省略`typename`。前者已经实现（C++11中的类型名可以在许多地方冗余使用），但后者还没有。

然而最近，有人再次呼吁在一些常见的上下文中将`typename`做成可选的，因为这些上下文对类型说明符的期望很明确：
- 在命名空间和类作用域中的函数和成员函数的返回类型与参数类型。在任何作用域中出现的函数、成员函数模板以及lambda表达式亦是如此。
- 声明的变量、变量模板以及静态数据成员的类型。对变量模板来说也一样。
- 在别名或别名模板的token `=` 之后的类型。
- 模板类型参数的默认实参。
- 跟随在`static_cast`, `const_cast`, `dynamic_cast`或是`reinterpret_cast`之后的尖括号内的类型。
- 在`new`表达式中命名的类型。

虽然这个列表相对来说是比较临时的，但事实证明，这种语言的改变将允许大多数使用`typename`的实例被省略，这将使代码更加紧凑和易读。

## 17.2 泛化的非类型模板参数

在非类型模板实参的限制中，最可能令模板初学者和老司机惊讶的是：没办法提供一个字符串字面值来作为模板实参。下面的例子看上去足够符合直觉：
```cpp
template<char const* msg>
class Diagnoser {
  public:
    void print();
};

int main() {
  Diagnoser<"Suprise!">().print();
}
```

然而，这里有些潜在的隐患。在标准C++中，当且仅当`Diagnoser`的两个实例拥有相同的实参时，它们俩的类型才是一致的。在该示例中，实参是一个指针值（换句话说，是个地址）。然而，在不同位置的两个字面上相同的字符串字面值却并不一定有相同的地址。这个时候我们就会发现`Diagnoser<"X">`和`Diagnoser<"X">`实际上是两种截然不同的类型且彼此并不兼容！（注意，`"X"`的类型是`char const[2]`，但是当它作为模板实参传递时，退化成了`char const *`。）

基于这些考虑，C++标准禁止将字符串字面值作为模板的实参。然而，一些（厂商编译器）实现提供这一功能作为扩展。它们通过在模板实例的内部表示中使用实际的字符串字面值内容来实现这一点。尽管这显然是可行的，但一些C++语言评论员认为，一个可以由字符串字面值替换的非类型模板参数应该与可以由地址替换的参数声明方式不同。一个可能的方法是将字符串字面值捕捉在一个字符参数包中。举个例子：
```cpp
template<char... msg>
class Diagnoser {
  public:
    void print();
};

int main() {
	// instantiates Diagnoser<’S’,’u’,’r’,’p’,’r’,’i’,’s’,’e’,’!’>
    Diagnoser<"Surprise!">().print();
}
```

我们还应该注意到这个问题的一个额外的技术细节。考虑以下模板声明，并假设语言已经扩展以接受字符串字面值作为模板参数的情况：
```cpp
template<char const* str>
class Bracket {
  public:
    static char const* address();
    static char const* bytes();
};

template<char const* str>
char const* Bracket<str>::address()
{
  return str; 
}

template<char const* str>
char const* Bracket<str>::bytes()
{
  return str;
}
```

在上述代码中，两个成员函数除了名字以外，其他都完全相同（这种情况不太寻常）。假设有一种实现采用了类似宏展开的方式对`Bracket<"X">`进行实例化：此时，如果两个成员函数被实例化到不同的编译单元，它们就会返回不同的值。有意思的是，在一些支持该扩展功能的C++编译器上进行测试后，发现它们有着这样的问题。

还有一个相关的议题，就是模板实参对浮点数字面值的支持（以及简单的常量浮点数表达式）。举个例子：
```cpp
template<double Ratio>
class Converter {
  public:
    static double convert (double val) {
      return val*Ratio;
    }
};   

using InchToMeter = Converter<0.0254>;
```

这个特性在某些C++实现中也予以了支持，同时也没什么技术上的挑战（与字符串字面值不同）。

C++11引入了字面值类类型的概念：一种可以在编译时接受常量值的类类型（包括通过`constexpr`函数进行的非平凡计算）。一旦这种类类型可用，马上就可以期待将它们用作非类型模板参数。然而，与上述描述的字符串字面值参数类似的问题出现了。特别地，两个类类型值的“相等性”并不是一个简单的问题，因为它通常是由操作符`==`的定义来确定的。这种相等性决定了两个实例是否相等，但实际上，链接器必须通过比较修饰后的名称来检查这种相等性。一个解决办法可能是在特定的字面值类中添加一个选项，标记它们具有平凡的相等性条件，即对类的标量成员进行两两比较。只有具有这种平凡相等性条件的类类型才被允许作为非类型模板参数类型。

## 17.3 函数模板的偏特化

在第16章中，我们讨论了类模板是如何做偏特化的，而函数模板仅支持简单的重载能力。这两种机制有些差异。

偏特化并没有引入一种新的模板：它是在既有模板（主模板）的基础上进行扩展。在查找类模板时，一开始只会考虑主模板。而在选择了主模板之后，如果发现有能够匹配模板实例的偏特化时，它的定义（也就是身体）就会被实例化出来以替代主模板的定义。（对完整特化来说也一样。）

相比之下，重载的函数模板是彼此完全独立的独立模板。在选择要实例化哪一个模板时，所有的重载模板都会被同时考虑，然后重载决议会尝试选出最适合的那一个。乍一看可能会觉着这种机制完全可以作为替代品，但在实践中还是有着诸多限制：
- 特化类的成员模板而不去修改类的定义是可行的。然而，增加重载的成员需要对类的定义进行修改。在多数情况下，我们由于没有这一权限而无法这样操作。此外，C++标准当前也不允许我们向`std`命名空间新增模板，但是它允许我们做模板的特化。
- 对重载函数模板来说，它们的参数必须有所区别。考虑这样一个函数模板`R convert(T const &)`，其中`R`和`T`是模板参数。我们非常想用`R = void`来特化这一模板，但使用重载是办不到的。
- 对于有效的未重载的函数，当函数一旦被重载后，可能会变得永久失效。特别是，对给定的两个函数模板`f(T)`和`g(T)`（其中T是模板参数），表达式`g(&f<int>)`当且仅当`f`没有被重载时才有效（否则就无法决定`f`指代哪一个函数）。
- 友元声明指代一个特定的函数模板或是特定的函数模板的实例化。函数模板的重载版本可能不会自动地授权原始模板的使用权限。

上述总总共同组织成了一个对支持函数模板偏特化这一能力的有力论点。

函数模板偏特化的自然语法可以从类模板中提炼：
```cpp
template<typename T>
T const& max(T const&, T const&);  // primary template

template<typename T>
T* const& max <T*>(T* const&, T *const&);  // partial specialization
```

一些语言设计者担心函数模板重载与这种偏特化实现之间的互动，举个例子：
```cpp
template<typename T>
void add(T& x, int i);  // a primary template

template<typename T1, typename T2>
void add(T1 a, T2 b);  // another(overloaded) primary template

template<typename T>
void add<T*> (T*&, int);  // Which primary template does this specialize?
```

然而，我们预计此类情况将被视为错误，不会对该功能的实用性产生重大影响。

在C++11标准化期间曾简要讨论了这一扩展，但相对而言大家意兴阑珊。尽管如此，这个话题偶尔还会出现，因为它巧妙地解决了一些常见的编程问题。也许它将在未来的C++标准中再次被采用。

## 17.4 命名的模板实参

512页章节21.4描述了一种技术，它可以让我们为特定的参数提供一个非默认模板实参，而无需指定其他的具有默认值的模板实参。尽管这是一种有取的技术，但很明显，为了达成这样一个简单的效果它做了太多的工作。因此，提供一种语言机制来命名模板参数是一个自然而然的想法。

