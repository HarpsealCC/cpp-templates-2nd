# 第14章 实例化
模板实例化就是从泛型模板定义中生成类型、函数和变量的过程。C++模板实例化的概念非常基础，但有时又错综复杂。这一复杂性的其中一个底层原因在于：模板生成的实体定义不再局限于源代码单一的位置。模板本身的位置、模板使用的位置以及模板实参定义的位置均在实体的含义中扮演着重要角色。

本章我们会讲解如何组织源代码来正确使用模板。此外，我们调查了最流行的C++编译器处理模板实例所使用的各种各样的方法。尽管所有的方法都应该语义等价，但理解编译器实例化策略的基本原则是大有裨益的。在构建实际软件时，每种机制都带有一些小怪癖，反过来，每种机制都影响了标准C++的最终规范。

## 14.1 On-Demand实例化
当C++编译器遇到模板特化的使用时，它会用需要的实参来替换模板参数，然后创造出特化体。这一过程是自动完成的，不需要客户端代码来引导（或者不需要模板定义来引导）。这一on-demand实例化特性使得C++与其他早期的编译型语言的类似功能大相径庭（如Ada或Eiffel，其中的一些语言需要显式地实例化引导，另外一些使用运行时分发机制来避免编译期实例化过程）。有时这也被称作隐式(implicit)抑或自动(automatic)实例化。

On-demand实例化意味着编译器常常需要访问模板完整的定义（换句话说，不只是声明）以及某些成员。考虑下面这一短小的源码文件：

```cpp
template<typename T> class C;	// #1 declaration only
C<int>* p = 0;					// #2 fine: definition of C<int> not needed

template<typename T>
class C{
  public:
    void f();					// #3 member declaration
};								// #4 class template definition completed

void g(C<int>& c)				// #5 use class template declaration only
{
  c.f();						// #6 use class template definition;
}								// will need definition of C::f() 
								// in this translation unit
								
template<typename T>
void C<T>::f()					// required definition due to #6
{
}
```

在源码的`#1`处，仅仅只有模板的声明，并没有定义（这种声明有时也被称作前置声明）。与普通类的情况一样，如果你声明的是一个指向某种类型的指针或引用（`#2`处的声明），那么在声明的作用域中，你并不需要看到该类模板的定义。例如，声明函数`g`的参数类型并不需要模板`C`的完整定义。然而，一旦某个组件需要知道模板特化体的大小或是访问了这种特化体的成员，那么就需要看到完整的类模板定义。这就解释了为什么`#6`处必须看到类模板的定义。若非如此，编译器无法确认该成员是否存在、是否可访问（非private或protected）。更进一步，成员函数定义也是需要的，因为`#6`处的调用需要确认`C<int>::f()`是否存在。

下面是另一个需要进行（前面的）类模板实例化的表达式，这是因为它需要`C<void>`的尺寸：
```cpp
C<void>* p = new C<void>;
```

本例中，需要实例化来保证编译器可以确定`C<void>`的尺寸，该new表达式需要去确认要分配多少存储空间。你可能会发现，对这一模板来说，替换模板参数`T`的实参`X`的类型无论是什么，都不会影响模板的尺寸，毕竟`C<X>`是一个空类（没有成员变量或虚函数）。然而，编译器并不会通过分析模板定义来避免实例化（所有编译器实际上都会进行实例化）。此外，对于上例来说，为了确定`C<void>`是否有可访问的默认构造器并确保`C<void>`没有成员`operator new`或`operator delete`操作符函数，实例化也同样是必要的。

在源码中是否需要访问类模板的成员并不总是那么直观。例如，C++重载解析规则要求：如果候选函数的参数是类类型，那么该类类型就必须是可见的：

```cpp
template<typename T>
class C {
  public:
    C(int);		// a constructor that can be called with a single parameter
};				// may be used for implicit conversions

void candidate(C<double>);	// #1
void candidate(int) { }		// #2

int main()
{
  candidate(42);		// both previous function declarations can be called
}
```

调用`candidate(42)`会采用`#2`处的声明。然而，在`#1`处的声明也会被实例化来检查对于这个调用来说它是否是可用的候选者（这个例子中，由于模板的单实参构造器可以把42隐式转换成一个类型为`C<double>`的右值）。请注意，如果模板不经实例化也可以找到调用函数（合适的候选），编译器还是被允许（但没被要求）执行该实例化（上例的情景中，由于有精准匹配的候选者，隐式转换的那个不会被选择）。另外，令我们的惊讶的是：`C<double>`的实例化可能还会触发一个错误。

## 14.2 延迟实例化
到目前为止所展示的这些例子，和使用非模板类相比并没有本质上的区别。譬如，非模板类的许多用法会要求类类型的完整性（参考P154节10.3.1）。而对模板来说，编译器会用类模板定义来生成完整的定义。

现在就有了一个相关的问题：模板实例化的程度如何？下面有一个模糊的答案：会实例化到它实际需要的程度。换句话说，编译器在实例化模板时应该是“懒惰”的。让我们来细究“懒惰”在这里的真正意义。

### 14.2.1 部分实例化和完整实例化
如我们之前所见，编译器有时不需要替换类或函数模板的完整定义。例如：

```cpp
template<typename T> T f(T p) { return 2*p; }
decltype(f(2)) x = 2;
```

本例中，`decltype(f(2))`所指示的类型并不需要函数模板`f()`的完整实例化。编译器因此只被允许替换`f()`的声明，而不是替换整个“身体”。这有时被称为部分实例化(partial instantiation)。

同样，如果引用类模板的实例而不需要将该实例作为完整类型，则编译器不应对该类模板实例执行完整的实例化。考虑下面的例子：

```cpp
template<typename T> class Q {
  using Type = typename T::Type;
};

Q<int>* p = 0;		// OK: the body of Q<int> is not substituted
```

在这里，`Q<int>`完整的实例化会触发一个错误，因为在`T`是`int`类型时，`T::Type`并没有意义。但是因为本例并不需要完整的`Q<int>`，所以不会执行完整实例化，代码也是OK的(尽管可疑)。

变量模板也有“完整”和“部分”实例化的区别。下面的例子用以阐释：
```cpp
template<typename T> T v = T::default_value();
decltype(v<int>) s;		// OK: initializer of v<int> not instantiated
```

`v<int>`的完整实例化会引起错误，但是如果只是需要变量模板实例的类型的话，是不需要进行完整实例化的。

有意思的是，别名模板没有这一区别：不存在两种方法来替换它们。

在C++中，当谈到“模板实例化”而没有说特定的完整或部分实例化时，往往意味着前者。也就是说，默认情况我们指的都是完整实例化。

### 14.2.2 实例化组件
当类模板隐式（完整）实例化时，其所有成员的声明也都会进行实例化，但是对应的定义却并不会实例化（即，成员是部分实例化的）。对此有一些特殊情况：首先，如果类模板包含一个匿名的联合体(union)，该联合体的成员的定义也会实例化；另一个特殊的情况出现在虚成员函数场景中，它们的定义作为模板实例化的结果，可能会也可能不会进行实例化。实际上，许多实现都会实例化该定义，因为“实现虚函数调用机制的内部结构”需要虚函数有一个链接实体存在。

实例化模板时，默认函数调用实参被单独考虑。具体来说，除非调用该函数（或成员函数）时确实使用了默认实参，否则它们不会被实例化。反之，如果调用该函数时显式地指定了实参去覆盖这一默认实参，那么默认实参就不会被实例化。

类似的，除非有必要，异常规范和默认成员初始化器也不会被实例化。

让我们用一些例子来阐释这些原则：

*details/lazy1.hpp*
```cpp
template<typename T>
class Safe {
};

template<int N>
class Danger {
  int arr[N];		// OK here, although would fail for N<=0
};

template<typename T, int N>
class Tricky {
  public:
    void noBodyHere(Safe<T> = 3);	// OK until usage of default value results in an error
	void inclass() {
	  Danger<N> noBoomYet;			// OK until inclass() is used with N<=0
	}
	struct Nested {
	  Danger<N> pfew;				// OK until Nested is used with N<=0
	};
	union {							// due anonymous union:
	  Danger<N> anonymous;			// OK until Tricky is instantiated with N<=0
	  int aligh;
	};
	void unsafe(T (*p)[N]);			// OK until Tricky is instantiated with N<=0
	void error(){
	  Danger<-1> boom;				// always ERROR (which not all compilers detect)
	}
};
```

标准C ++编译器将审查这些模板定义以检查语法和常规语义约束。这样做时，当检查涉及模板参数的约束时，它将“假设最佳”。举个例子，`Danger::arr`的成员参数`N`可能是零或负数（非法的），但是编译器会假定不会出现这种情况。`inclass()`，`struct Nested`，匿名联合体的定义因而都没有问题。

出于同样的原因，只要N还是一个未被替换的模板参数时，成员`unsafe(T (*p)[N])`的声明也不是问题。

`noBodyHere()`的默认实参规格声明(=3)看起来很诡异，因为模板`Safe<>`并不能以一个整型数来初始化，但是编译器会假定：对于`Safe<T>`泛型定义来说，它实际上并不需要默认实参；或者是`Safe<T>`的特化体会引入使用一个整型数来初始化的能力（见第16章）。然而，成员函数`error()`的定义必定会引起一个错误，即使模板尚未实例化，这是因为`Danger<-1>`的使用需要一个完整的类`Danger<-1>`的定义，也就会生成该类并尝试去定义一个负数尺寸的数组。有趣的是，虽然标准明确指出此段代码无效，但它还是允许编译器在未实际使用模板实例时不去诊断这个错误。也就是说，只要`Tricky<T,N>::error()`对任何具体的`T`和`N`类型都未被使用，那么编译器就不用抛出这个错误。例如，GCC和Visual C++在撰写此书时都不会抛出这一个错误。

让我们来分析一下，在增加下面的一行定义语句时，会发生什么：
```cpp
Tricky<int, -1> inst;
```

这将引起编译器（完整）实例化`Tricky<int, -1>`，在模板`Tricky<>`定义中替换`T`为`int`，`N`为`-1`。并非所有的成员定义都是必要的，但是默认构造器和析构器（本例中都是隐式声明的）一定会被调用到，因此它们的定义必须是可用的（在我们的例子中，它们都会隐式生成）。如上所述，`Tricky<int, -1>`的成员会部分实例化（即，它们的声明会被替换）：这一过程可能会引起错误。例如，`unsafe(T (*p)[N])`的声明创建了一个负数尺寸的数组类型，这就是一个错误。类似的，`anonymous`成员现在也会抛出一个错误，因为并不能生成`Danger<-1>`类型。另一方面，成员`inclass()`和`struct Nested`的定义现在还不会被实例化，因此对完整类型`Danger<-1>`的需求并不会产生错误（它们都包含了一个无效的数组定义）。

如上所述，当实例化一个模板时，对于虚函数实际上是需要提供定义的。否则，就会遇到链接错误。例如：
*details/lazy2.cpp*
```cpp
template<typename T>
class VirtualClass {
  public:
    virtual ~VirtualClass() {}
	virtual T vmem();		// Likely ERROR if instantiated without definition
};

int main()
{
  VirtualClass<int> inst;
}
```

最后，`operator->`值得留意。考虑：
```cpp
template<typename T>
class C{
  public:
    T operator-> ();
};
```

通常来说，`operator->`必须返回一个指针类型或是另一个应用了`operator->`的类类型。`C<int>`的完全体会触发一个错误，因为它声明了一个`int`返回类型的`operator->`。然而，因为某些常见的类模板定义实现了这种（返回类型为`T`或者`T*`）定义，所以语言规则更加灵活。于是，只有在重载解析规则确实选择了用户自定义的`operator->`时，才要求该自定义`operator->`只能返回一个应用了其他（例如，内建的）`operator->`的类型。这甚至对模板之外的代码也同样生效（尽管这种松弛法则(relaxed behavior)在那些上下文中用处不大）。因此，这里的声明不会触发错误，尽管`int`会替代该返回类型。

## 14.3 C++实例化模型
模板实例化就是从对应的模板实体通过合适地模板参数替换来得到一个常规的类型、函数或是变量的过程。这可能听起来直截了当，但实际上需要遵循非常多的细节。

### 14.3.1 两阶段查找
在第13章中，我们曾看到依赖型名称无法在解析模板时被找到。取而代之的是，它们会在实例化的时刻再次进行查找。非依赖型名称则会在更早的阶段被查找，因此当模板第一次看到它的时候，就可以诊断出许多错误。这就引出了“两阶段查找”的概念。第一阶段查找发生在解析模板的时候，而第二阶段查找发生在模板实例化的时候：
1. 在第一阶段，当解析模板时，非依赖型名称会并用普通查找规则和ADL规则（如果可行的话）。非受限的依赖型名称（诸如函数调用中的函数名称，它们之所以是依赖型名称，是因为它们具有依赖型实参）会使用普通查找规则，但是这一查找结果并不会作为最终结果，而是要等到第二阶段的另一个查找过程完成（也就是模板实例化的时候）。
2. 在第二阶段，此时的模板实例化被称作POI(point of instantiation)，依赖型受限名称会在此时被查找（对选定的实例用模板实参替换模板参数），而且还会对非受限依赖型名称进行额外的ADL查找（它们曾在第一阶段进行过普通查找）。

对非受限依赖型名称，首次的普通查找（并不是终态）被用来判断该名称是否是一个模板。考虑下面的例子：
```cpp
namespace N {
  template<typename> void g() {}
  enum E { e };
}

template<typename> void f() {}

template<typename T> void h(T p) {
  f<int>(p);		// #1
  g<int>(p);		// #2 ERROR
}

int main() {
  h(N::e);			// calls template h with T = N::E
}
```

在`#1`行，当看到跟着一个`<`的名称`f`时，编译器就需要判断`<`到底是一个尖括号还是一个小于号。这取决于`f`是否是一个已知的模板名称。在本例中，普通查找会找到`f`的声明，它确实是一个模板，因此这里会以尖括号来成功解析。

而在`#2`行，这里会产生一个错误，这是因为普通查找并不能找到模板`g`，因此，`<`就被认为是一个小于号操作符，对于我们的例子来说这就是个语法错误。如果想让该解析通过，那么在用`T` = `N::E`实例化`h`的时候最终得用ADL找到一个模板`N::g`（尽管`N`是与`E`关联的命名空间），但是只有先成功解析`h`的泛型定义，这才能行得通。

> 译者注：这里给的例子挺奇怪的，我觉着可以给g和f都增加一个模板参数作为函数参数。否则没有参数，`f<int>(p)`一样通不过。

### 14.3.2 POI
如上所述，C++编译器会在模板客户单代码的某些位置访问模板实体的声明或者定义。当某些代码结构引用了模板特化，而且为了生成该特化需要实例化相应的模板定义时，就会在源代码中产生一个POI。POI是源代码中的一个点，在这里会插入已被替换的模板。例如：

```cpp
class MyInt {
  public:
    MyInt(int i);
};

MyInt operator - (MyInt const&);

bool operator > (MyInt const&, MyInt const&);

using Int = MyInt;

template<typename T>
void f(T i)
{
  if(i > 0) {
    g(-i);
  }
}

// #1 
void g(Int)
{
  // #2
  f<Int>(42);	// point of call
  // #3
}
// #4
```

C++编译器看到`f<Int>(42)`时，它知道模板`f`需要用`MyInt`替换`T`来实例化：这就创造了一个POI。`#2`和`#3`与该调用点紧邻，但是它们都不是POI，因为C++不允许我们在这里插入`::f<Int>(Int)`的定义。另外，`#1`和`#4`两处的本质区别在于，在`#4`处，函数`g(Int)`是可见的，因此模板依赖的调用`g(-i)`可以在`#4`处被解析。然而，如果我们假定`#1`是POI的话，那么调用`g(-i)`将不能被解析，因为`g(Int)`在`#1`处是不可见的。幸运的是，对于函数模板特化的引用，C++把它的POI定义，置于紧跟在“包含这个引用的定义或声明所在的最近的命名空间作用域”之后。在我们的例子中，这个位置就是`#4`。

你可能会想要知道为什么这个例子引入了类型`MyInt`而不是用`int`基础类型。这是因为，在POI执行的第二次查找（指`g(-i)`）仅仅使用了ADL，而基础类型`int`并没有关联的命名空间，因此，如果使用`int`类型，就不会发生ADL查找，也就不能找到函数`g`。所以，如果你用下面的类型别名声明语句：
```cpp
using Int = int;
```
代码将无法通过编译。下面的例子有着类似的问题：
```cpp
template<typename T>
void f1(T x)
{
  g1(x);	// #1
}

void g1(int)
{
}

int main()
{
  f1(7);	// ERROR: g1 not found!
}
// #2 POI for f1<int>(int)
```

`f1(7)`调用为`f1<int>(int)`创造了一个POI紧随其后（在位置`#2`）。在这一实例中，关键点在于函数`g1`的查找。当首次遇到模板定义`f1`时，它会注意到非受限名称`g1`是一个依赖型名称，因为它作为一个函数名称，有着依赖型实参（实参`x`的类型取决于模板参数`T`）。因此，`g1`会在`#1`处使用普通查找规则，然而，在`#1`处找不到任何的`g1`。在`#2`处，即POI处，函数名称被再一次查找（在关联的命名空间和类中），但是唯一的实参类型是一个`int`型，它根本没有关联的命名空间和类。因此，`g1`永远都无法被找到，尽管在这里（POI处）哪怕用普通查找都可以找到`g1`。

变量模板的POI的处理与函数模板相似。而对于类模板特化来说，情况则不太相同，如下例所示：
```cpp
template<typename T>
class S {
  public:
    T m;
};

// #1 
unsigned long h()
{
  // #2
  return (unsigned long)sizeof(S<int>);
  // #3
}
// #4
```

一样地，`#2`和`#3`都不能作为POI，因为这里不能进行命名空间作用域类`S<int>`的定义（模板是不能出现在函数作用域内部的）。如果我们遵循函数模板实例的规则，POI会出现在位置`#4`处，但是这样一来表达式`sizeof(S<int>)`就是无效的，因为`S<int>`的尺寸直到`#4`之后才能被确定。因此，生成的类模板实例的引用被紧邻地定义在包含该引用的声明或定义的命名空间作用域之前。在我们的例子中，这个位置就是`#1`。

当模板实例化时，可能还会产生某些额外的实例化。考虑这一简短的例子：
```cpp
template<typename T>
class S {
  public:
    using I = int;
};

// #1
template<typename T>
void f()
{
  S<char>::I var1 = 41;
  typename S<T>::I var2 = 42;
}

int main()
{
  f<double>();
}
// #2: #2a, #2b
```

根据我们之前的讨论，`f<double>()`的POI位于`#2`处。函数模板`f()`还引用了类模板特化`S<char>`，它的POI位于`#1`处。与此同时它还引用了`S<T>`，但是因为这仍然是一个依赖型名称，我们此时此刻无法真正完成实例化。然而，如果我们在`#2`处实例化`f<double>()`，我们会注意到同时也需要实例化`S<double>`的定义。这种副(secondary)POI（或这叫过渡的POI）的定义位置会有些差异。对于函数模板，副POI与主(primary)POI严格一致；而对于类模板，副POI会（在最近的命名空间作用域中）先于主POI。在我们的例子中，这意味着`f<double>()`会被放在`#2b`处，而前面紧邻的`#2a`处会是`S<double>`的副POI。注意，这与`S<char>`的POI位置摆放完全不同。

编译单元通常会包含相同实例的多个POI。对类模板实例，在每个编译单元中，只有首个POI会被保留，后续的那些都会被忽略（它们不会被真正视为POI）。对函数模板实例和变量模板实例，所有的POI都会被保留。无论是哪一种情形，ODR原则都会要求：对保留的任何一个POI处所出现的同种实例化体，都必须是等价的；但是C++编译器既不需要保证这一原则，也不需要诊断是否违反这一原则。这就允许一个C++编译器选择一个非类类型的POI来执行实际的实例化，而不用担心另一个POI会产生一个不同的实例。

在实际应用中，大多数编译器会延迟大部分函数模板的实例化，直到编译单元末尾处（才进行真正的实例化）。某些实例化不能被拖延，这包括：判定某个推导的返回类型所需要的实例化场合（参考P296节15.10.1和P303节15.10.4）、函数是`constexpr`且必须产生一个常量结果的场合。一些编译器在首次用于潜在地内联调用时会立刻实例化内联函数。这种做法有效的将对应的模板特化的POI转移到了编译单元末尾处，而这作为一种可选择的POI（方式），被C++标准所允许。

### 14.3.3 包含式模型
当遇到POI时，对应模板的定义必须是可访问的。对类特化来说，这意味着类模板定义必须在编译单元中被更早地看见。而对函数模板和变量模板（以及类模板的成员函数和静态数据成员）的POI来说，也同样需要。典型的模板定义被简单的通过`#include`语句引入到编译单元，尽管是非类型模板也一样。这种模板定义的源码模型被称为包容式模型，它目前是当下C++标准所支持的模板的唯一自动的源码模型。

尽管包含式模型鼓励程序员将所有模板定义都放在头文件中，以便它们可以满足可能出现的任何POI，但显式地使用“显式实例化声明(explicit instantiation declarations)”和“显式实例化定义(explicit instantiation definitions)”（P260节14.5）来管理实例化也是可行的。从逻辑上讲，这样做并不是一件容易的事，大多数时候程序员会更喜欢依靠自动的实例化机制。用自动方案实现的一个挑战是要解决跨不同编译单元为函数模板或变量模板（或类模板实例的相同成员函数或静态数据成员）的特化体实现完全相同的POI。我们随后会讨论这个问题的解法。

## 14.4 几种实现方案
本节我们来回顾一下支持包含式模型的几种C++实现。所有的这些实现都依赖于两个基础组件：编译器和链接器。编译器将源代码编译成对象文件，它们包含机器码和符号注释（跨引用其他对象文件和库）。链接器通过组合这些对象文件解决它们包含的跨引用符号来创建可执行程序或库文件。在下面的内容中，即使完全有可能（但不流行）以其他方式实现C ++（例如，你可以假想出一个C++解释器。），我们也将采用这种模型。

当类模板特化在多个编译单元中被使用时，编译器会为每个编译单元重复实例化过程。这几乎不会造成什么问题，因为类定义不会直接创建低级代码。它们仅仅由C++实现体在内部使用，用来审查并解释各种其他表达式和声明。在这方面，类定义的多个实例化体与类定义的多个包含（在不同编译单元中通常通过头文件包含）没有实质性区别。

然而，如果你实例化一个（非内联）函数模板，情况就有些不同了。如果你想提供某个普通的非内联函数的多个定义，那么就会违反ODR原则。例如，假设你编译和链接下面这两个文件：
```cpp
// ==== a.cpp:
int main()
{
}

// ==== b.cpp:
int main()
{
}
```

C++编译器会对每个模块进行单独编译，此时没有什么问题，因为在每个编译单元内它们都合法。然而，如果你想把它们链接在一起，你的链接器很大可能会抗议：不允许出现重复的定义。

反之，我们考虑模板的场合：
```cpp
// ==== t.hpp:
// common header (inclusion model)
template<typename T>
class S {
  public:
    void f();
};

template<typename T>
void S::f()		// member definition
{
}

void helper(S<int>*);
// ==== a.cpp:
#include "t.hpp"
void helper(S<int>* s)
{
  s->f();	// #1 first point of instantiation of S::f
}

// ==== b.cpp:
#include "t.hpp"
int main()
{
  S<int> s;
  helper(&s);
  s.f();	// #2 second point of instantiation of S::f
}
```

如果链接器处理类模板实例化的成员函数与处理普通函数或成员函数的方式一致，那么编译器就需要保证它只会生成一份代码，要么在`#1`处生成，要么在`#2`处生成（两处POI的位置）。为了达成这一目标，编译器需要在每个编译单元中都携带其他的编译单元的信息，而这对于C++编译器来说在引入模板之前是从未有过的要求。接下来，我们讨论C ++实现中已使用的三大类解决方案。

请注意，模板实例化产生的所有的链接实体都有同样的问题：实例化的函数模板和成员函数模板，以及实例化的静态数据成员和实例化的变量模板。

### 14.4.1 贪婪实例化

