# 第14章 实例化
模板实例化就是从泛型模板定义中生成类型、函数和变量的过程。C++模板实例化的概念非常基础，但有时又错综复杂。这一复杂性的其中一个底层原因在于：模板生成的实体定义不再局限于源代码单一的位置。模板本身的位置、模板使用的位置以及模板实参定义的位置均在实体的含义中扮演着重要角色。

本章我们会讲解如何组织源代码来正确使用模板。此外，我们调查了最流行的C++编译器处理模板实例所使用的各种各样的方法。尽管所有的方法都应该语义等价，但理解编译器实例化策略的基本原则是大有裨益的。在构建实际软件时，每种机制都带有一些小怪癖，反过来，每种机制都影响了标准C++的最终规范。

## 14.1 On-Demand实例化
当C++编译器遇到模板特化的使用时，它会用需要的实参来替换模板参数，然后创造出特化体。这一过程是自动完成的，不需要客户端代码来引导（或者不需要模板定义来引导）。这一on-demand实例化特性使得C++与其他早期的编译型语言的类似功能大相径庭（如Ada或Eiffel，其中的一些语言需要显式地实例化引导，另外一些使用运行时分发机制来避免编译期实例化过程）。有时这也被称作隐式(implicit)抑或自动(automatic)实例化。

On-demand实例化意味着编译器常常需要访问模板完整的定义（换句话说，不只是声明）以及某些成员。考虑下面这一短小的源码文件：

```cpp
template<typename T> class C;	// #1 declaration only
C<int>* p = 0;					// #2 fine: definition of C<int> not needed

template<typename T>
class C{
  public:
    void f();					// #3 member declaration
};								// #4 class template definition completed

void g(C<int>& c)				// #5 use class template declaration only
{
  c.f();						// #6 use class template definition;
}								// will need definition of C::f() 
								// in this translation unit
								
template<typename T>
void C<T>::f()					// required definition due to #6
{
}
```

在源码的`#1`处，仅仅只有模板的声明，并没有定义（这种声明有时也被称作前置声明）。与普通类的情况一样，如果你声明的是一个指向某种类型的指针或引用（`#2`处的声明），那么在声明的作用域中，你并不需要看到该类模板的定义。例如，声明函数`g`的参数类型并不需要模板`C`的完整定义。然而，一旦某个组件需要知道模板特化体的大小或是访问了这种特化体的成员，那么就需要看到完整的类模板定义。这就解释了为什么`#6`处必须看到类模板的定义。若非如此，编译器无法确认该成员是否存在、是否可访问（非private或protected）。更进一步，成员函数定义也是需要的，因为`#6`处的调用需要确认`C<int>::f()`是否存在。

下面是另一个需要进行（前面的）类模板实例化的表达式，这是因为它需要`C<void>`的尺寸：
```cpp
C<void>* p = new C<void>;
```

本例中，需要实例化来保证编译器可以确定`C<void>`的尺寸，该new表达式需要去确认要分配多少存储空间。你可能会发现，对这一模板来说，替换模板参数`T`的实参`X`的类型无论是什么，都不会影响模板的尺寸，毕竟`C<X>`是一个空类（没有成员变量或虚函数）。然而，编译器并不会通过分析模板定义来避免实例化（所有编译器实际上都会进行实例化）。此外，对于上例来说，为了确定`C<void>`是否有可访问的默认构造器并确保`C<void>`没有成员`operator new`或`operator delete`操作符函数，实例化也同样是必要的。

在源码中是否需要访问类模板的成员并不总是那么直观。例如，C++重载解析规则要求：如果候选函数的参数是类类型，那么该类类型就必须是可见的：

```cpp
template<typename T>
class C {
  public:
    C(int);		// a constructor that can be called with a single parameter
};				// may be used for implicit conversions

void candidate(C<double>);	// #1
void candidate(int) { }		// #2

int main()
{
  candidate(42);		// both previous function declarations can be called
}
```

调用`candidate(42)`会采用`#2`处的声明。然而，在`#1`处的声明也会被实例化来检查对于这个调用来说它是否是可用的候选者（这个例子中，由于模板的单实参构造器可以把42隐式转换成一个类型为`C<double>`的右值）。请注意，如果模板不经实例化也可以找到调用函数（合适的候选），编译器还是被允许（但没被要求）执行该实例化（上例的情景中，由于有精准匹配的候选者，隐式转换的那个不会被选择）。另外，令我们的惊讶的是：`C<double>`的实例化可能还会触发一个错误。

## 14.2 延迟实例化
到目前为止所展示的这些例子，和使用非模板类相比并没有本质上的区别。譬如，非模板类的许多用法会要求类类型的完整性（参考P154节10.3.1）。而对模板来说，编译器会用类模板定义来生成完整的定义。

现在就有了一个相关的问题：模板实例化的程度如何？下面有一个模糊的答案：会实例化到它实际需要的程度。换句话说，编译器在实例化模板时应该是“懒惰”的。让我们来细究“懒惰”在这里的真正意义。

### 14.2.1 部分实例化和完整实例化
如我们之前所见，编译器有时不需要替换类或函数模板的完整定义。例如：

```cpp
template<typename T> T f(T p) { return 2*p; }
decltype(f(2)) x = 2;
```

本例中，`decltype(f(2))`所指示的类型并不需要函数模板`f()`的完整实例化。编译器因此只被允许替换`f()`的声明，而不是替换整个“身体”。这有时被称为部分实例化(partial instantiation)。

同样，如果引用类模板的实例而不需要将该实例作为完整类型，则编译器不应对该类模板实例执行完整的实例化。考虑下面的例子：

```cpp
template<typename T> class Q {
  using Type = typename T::Type;
};

Q<int>* p = 0;		// OK: the body of Q<int> is not substituted
```

在这里，`Q<int>`完整的实例化会触发一个错误，因为在`T`是`int`类型时，`T::Type`并没有意义。但是因为本例并不需要完整的`Q<int>`，所以不会执行完整实例化，代码也是OK的(尽管可疑)。

变量模板也有“完整”和“部分”实例化的区别。下面的例子用以阐释：
```cpp
template<typename T> T v = T::default_value();
decltype(v<int>) s;		// OK: initializer of v<int> not instantiated
```

`v<int>`的完整实例化会引起错误，但是如果只是需要变量模板实例的类型的话，是不需要进行完整实例化的。

有意思的是，别名模板没有这一区别：不存在两种方法来替换它们。

在C++中，当谈到“模板实例化”而没有说特定的完整或部分实例化时，往往意味着前者。也就是说，默认情况我们指的都是完整实例化。