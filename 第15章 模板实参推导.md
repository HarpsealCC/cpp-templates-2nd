# 第15章 模板实参推导
如果为每个函数模板都显式地指定模板实参，那么很快代码就会显得又笨又重（比如：`concat<std::string, int>(s, 3)`）。幸运的是，C++编译器常常可以自动判断模板实参类型，这是通过一个十分高效的过程——模板实参推导——来完成的。

本章中我们将详述模板实参推导这一过程的细节。和C++其他的知识一样，大多数规则通常会产生一个直观的结果，模板实参推导也不例外。此外，对这一章的深刻理解可以使我们以后避免遇到出人意料的情景。

尽管模板实参推导是为了简化函数模板的调用而首先开发的，但是自那以后，它已扩展到适用于其他几种用途，包括从其初始值设定项(initializer)确定变量的类型。

## 15.1 推导过程
基本的推导过程会比较“函数调用的实参类型”与“函数模板对应位置的参数化类型”，然后针对要被推导的一到多个参数，分别尝试去推断一个正确的替换项。每个实参-参数对都会独立分析，并且如果最终得出的结论产生矛盾(differ)，那么推导过程就失败了。

考虑下面的例子：
```cpp
template<typename T>
T max(T a, T b)
{
  return b < a ? a : b;
}

auto g = max(1, 1.0);
```

这里第一个调用实参的类型是`int`，因此我们原生的`max()`模板的参数`T`会被姑且推导成`int`。然而，第二个调用实参是`double`类型，基于此，`T`会被推导为`double`：这就与前一个推导产生了矛盾。注意：我们称之为“推导过程失败”，而不是“程序非法”。毕竟，可能对于另一个名为`max`（函数模板可以像普通函数那样被重载；参考P15节1.5和第16章）的模板来说推导过程可能是成功的。

即使所有被推导的模板实参都可以一致地确定（即不产生矛盾），推导过程仍然可能会失败。这种情况发生于：在函数声明中，进行替换的模板实参可能会导致无效的结构。请看下例：

```cpp
template<typename T>
typename T::ElementT at(T a, int i)
{
  return a[i];
}

void f(int* p)
{
  int x = at(p, 7);
}
```

这里`T`被推导为`int*`(`T`出现的地方只有一种参数类型，因此显然不会有解析矛盾)。然而，将`T`替换为`int*`在C++中对于返回类型`T::ElementT`显然是非法的，因此推导就失败了。

我们仍然需要探索实参-参数匹配如何进行。我们会使用下面的概念来进行描述：匹配类型A（来自实参的类型）和参数化类型P（来自参数的声明）。如果被声明的参数是一个引用，那么P就是所引用的类型，A仍然是实参的类型。如果声明的参数不是引用，那么P就是声明的参数类型，而A类型的获取则会经过数组和函数类型到指针类型的退化，并且会忽略顶层const和volatile限定符。例如：

```cpp
template<typename T> void f(T);		// parameterized type P is T
template<typename T> void g(T&);	// parameterized type P is also T

double arr[20];
int const seven = 7;

f(arr);		// nonreference parameter: 	T is double*
g(arr);		// reference parameter:		T is double[20]
f(seven);	// nonreference parameter: 	T is int
g(seven);	// reference parameter:		T is int const
f(7);		// nonreference parameter:	T is int
g(7);		// reference parameter:		T is int => ERROR: can't pass 7 to int&
```

对调用`f(arr)`来说，`arr`数组类型会退化为类型`double*`，作为推导的`T`的类型。在`f(seven)`中`const`限定符被忽略了，因此T被推导为`int`。相反地，`g(x)`推导`T`为类型`double[20]`(没有发生退化)。与此类似地，`g(seven)`有一个类型为`int const`的左值实参，并且因为在匹配引用参数时，`const`和`volatile`限定符不会被去除，`T`会被推导为`int const`。然而，注意由于`g(7)`想要推导`T`为`int`（因为非类的右值表达式永远不会有`const`或`volatile`限定类型），这一调用会失败，因为实参`7`无法作为一个`int&`类型的参数被传递。

引用类型的参数不会退化这一事实，对于参数为字符串字面量的场合来说可能会令人惊讶。重新审视我们的使用引用类型的`max()`模板声明：
```cpp
template<typename T>
T const& max(T const& a, T const& b);
```

对于表达式`max("Apple", "Pie")`来说，`T`被推断为`char const*`看起来很合理。然而，实际上`Apple`的类型是`char const[6]`、`Pie`的类型是`char const[4]`。这里并不会进行数组到指针的退化（因为推导涉及了引用类型的参数），因此想要推导成功，`T`必须既得是`char[6]`又得是`char[4]`。显然，这绝无可能。可以参考P115节7.4中对于如何处理这一场景的一个探讨。

## 15.2 推导上下文
比`T`复杂得多的参数化类型也可以匹配一个给定的实参类型。这里有一些相当基础的例子：
```cpp
template<typename T>
void f1(T*);

template<typename E, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1 (T2::*)(T3*));

class S {
  public:
    void f(double*);
};

void g(int*** ppp)
{
  bool b[42];
  f1(ppp);		// deduces T to be int**
  f2(b);		// deduces E to be bool and N to be 42
  f3(&S::f);	// deduces T1 = void, T2 = S, and T3 = double
}
```

复杂的类型声明都是用比它更基本的结构（例如指针、引用、数组、函数声明；成员指针声明；模板ID等）来组成的，匹配过程从最顶层结构开始处理，一路递归其各种组成元素。可以说基于这一方法，大部分类型声明结构都可以进行匹配，而这些结构也被称为“推导上下文“。然而，有些结构不能作为推导上下文。例如：
- 受限的类型名称。例如，形如`Q<T>::X`的类型名称永远不会用来推导模板参数`T`。
- 除了非类型参数之外，模板参数还包含其他成分的非类型表达式。例如，形如`S<I+1>`的类型名称永远不会用于推导`I`。再比如，`T`也不会通过匹配形如`int(&)[sizeof(S<T>)]`类型的参数来推导。这些限制合乎常理，因为通常来说，推导并不是唯一的（甚至不一定是有限的），尽管有时候会很容易忽略这些受限的类型名称。此外，一个不能推导的上下文并不会自动地表明：所对应的程序有错误，或者甚至前面分析过的参数不能再次进行类型推导。为了阐释这一事实，考虑下面这个更为错综复杂的例子：
```cpp
template<int N>
class X {
  public:
    using I = int;
	void f(int) {}
};

template<int N>
void fppm(void (X<N>::*p)(typename X<N>::I));

int main()
{
  fppm(&X<33>::f);		// fine: N deduced to be 33
}
```

在函数模板`fppm()`中，子结构`X<N>::I`是一个不可推导的上下文。然而，具有成员指针类型（即`X<N>::*p`）的成员类型部分`X<N>`是一个可推导上下文。于是，可以根据这个可推导上下文获得参数`N`，然后把`N`放入不可推导的上下文`X<N>::I`，就能获得与实参`＆X<33>::f`相配的类型。因此基于这个实参-参数对的推导就是成功的。

相反，对于完全依赖推导上下文的参数类型来说，有可能会产生推导矛盾。例如，假设我们已恰当地声明过类模板`X`和`Y`：
```cpp
template<typename T>
void f(X<Y<T>, Y<T>>);

void g()
{
  f(X<Y<int>, Y<int>>());	// OK
  f(X<Y<int>, Y<char>>());	// ERROR: deduction fails
}
```

第二个调用的问题在于两个实参对于参数`T`的推导是不同的，而这显然是无效的（两种情景里，函数调用实参都是一个临时的对象，这一对象借由调用类模板`X`的默认构造器而获得）。

## 15.3 特殊的推导情况
存在一些特殊的情况：用于推导的实参-参数对（A, P）并不是分别来自于函数调用的实参和函数模板的参数。第一种情况出现在取函数模板地址的时候。此时，P是函数模板声明的参数化类型（即下面`f`的类型），而A是被赋值（或者初始化）的指针（即下面的`pf`）所代表的函数类型。例如：
```cpp
template<typename T>
void f(T, T);

void (*pf)(char,char) = &f;
```

在本例中，P是`void(T, T)`，而A是`void(char, char)`。推导随着`T`被`char`替换而成功，而`pf`用特化体`f<char>`的地址进行初始化。

类似地，函数类型在一些其他特殊情况下也被P和A所使用：
- 确定重载函数模板之间的偏序
- 将某个显式特化体与某个函数模板匹配
- 将某个显式实例化体与某个模板匹配
- 将某个友元函数模板特化体与某个模板匹配
- 将占位(replacement)`operator delete`或是`operator delete[]`与对应的占位`operator new`或`operator new[]`模板匹配。

这些话题中的部分内容，以及类模板偏特化中模板实参推导的使用，会在第16章中进行展开。

另一种特殊情况和转型运算符模板一起出现。例如：
```cpp
class S {
  public:
    template<typename T> operator T&();
};
```

在本例中，实参-参数对(P, A)的获取涉及到我们试图进行转型的实参和转换运算符的返回类型。下面的代码清楚地说明了这种情况：
```cpp
void f(int (&)[20]);

void g(S s)
{
  f(s);
}
```

这里，我们试图把`S`转型为`int(&)[20]`，因此，类型A为`int[20]`，而类型P为`T`。当`T`被`int[20]`替换时，推导就是成功的。

最后，对于`auto`占位类型来说，也需要一些特殊的对待。这会在P303节15.10.4中进行讨论。

## 15.4 初始化列表(initializer list)
当函数调用的实参是一个初始化列表时，该实参是没有一个特定的类型的，因此通常来说，对于给定实参-参数对(A, P)，不会进行任何推导，因为这里并不存在A。例如：
```cpp
#include <initializer_list>

template<typename T> void f(T p);

int main() {
  f({1, 2, 3});		// ERROR: cannot deduce T from a braced list
}
```

然而，如果参数类型P（在移除引用、顶层const和volatile限定符后）与`std::initializer_list<P'>`等价（对某些类型`P'`来说有一个可推导的模式(deducible pattern))，推导过程会将初始化列表的每个元素类型与`P'`进行比较，只有在所有的元素类型都有相同的类型时，推导才是成功的。
*deduce/initlist.cpp*
```cpp
#include <initializer_list>

template<typename T> void f(std::initializer_list<T>);

int main()
{
	f({2,3,5,7,9});						// OK: T is deduced to int
	f({'a', 'e', 'i', 'o', 'u', 42});	// ERROR: T deduced to both char and int
}
```

类似地，如果参数类型`P`是一个`P'`类型数组的引用（有一个可推导的模式），推导过程也会将初始化列表的每个元素的类型与`P'`进行比较，当且仅当所有元素都有相同的类型时，推导成功。此外，如果（数组）边界有一个可推导模式（即，仅命名一个非类型模板参数），那么该边界会被推导为初始化列表中元素的数量。

## 15.5 参数包
推导过程会逐一匹配每个实参到每个参数来确定模板实参的值。然而在对可变模板进行模板实参推导时，参数和实参之间1比1的关系就被打破了，这是因为一个参数包可以匹配多个实参。在本例中，同一个参数包(P)被匹配到了多个实参(A)，并且每次匹配都会为P中的任何模板参数包产生附加值：

```cpp
template<typename First, typename... Rest>
void f(First first, Rest... rest);

void g(int i, double j, int* k)
{
  f(i, j, k);	// deduces First to int, Rest to {double, int*}
}
```

此处对首个函数参数的推导很简单，毕竟它并没有卷入任何参数包。第二个函数参数，`rest`，是一个函数参数包。它的类型是一个包展开(`Rest...`)，其模式为类型`Rest`：该模式用作P，与第二和第三调用参数的类型A进行比较。当匹配第一个A时（类型`double`），模板参数包`Rest`的第一个值被推导为`double`。类似地，与第二个A进行匹配时，模板参数包`Rest`的第二个值被推导为`int*`。因此，推导确定了参数包`Rest`的值序列为`{double, int*}`。替换这一推导以及第一个函数参数的结果就可以得到函数类型`void(int, double, int*)`，它与函数调用的每个实参类型相匹配。

由于函数参数包使用了展开的模式进行比较，因此该模式可以任意复杂，并且可以从每种实参类型中确定多个模板参数和参数包的值。考虑下面的函数`h1()`和`h2()`的推导行为：
```cpp
template<typename T, typename U> class pair { };

template<typename T, typename... Rest>
void h1(pair<T, Rest> const&...);
template<typename... Ts, typename... Rest>
void h2(pair<Ts, Rest> const&...);

void foo(pair<int, float> pif, pair<int, double> pid, pair<double, double> pdd) 
{
  h1(pif, pid);	// OK: deduces T to int, Rest to {float, double}
  h2(pif, pid);	// OK: deduces Ts to {int, int}, Rest to {float, double}
  h1(pif, pdd);	// ERROR: T deduced to int from the 1st arg, but to double from the 2nd
  h2(pif, pdd);	// OK: deduces Ts to {int, double}, Rest to {float, double}
}
```

对`h1()`和`h2()`来说，P是为推导的每个实参类型调整成了非受限引用版本（分别为`pair<T, Rest>`和`pair<Ts, Rest>`）的引用类型。由于所有的参数和实参都是类模板`pair`的特化体，因此将比较模板参数。对`h1()`来说，首个模板实参`T`并非参数包，因此它的值会为每个实参所独立推导。如果推导的结果出现矛盾（正如第二个`h1`调用那样），推导就失败了。对第二个在`h1()`和`h2()`的`pair`模板实参`Rest`、以及`h2()`的第一个模板实参`Ts`来说，推导会根据A的每个实参类型来确定模板参数包的值。

参数包的推导不限于其中“实参-参数对”来自调用参数的函数参数包。实际上，在函数参数列表或模板参数列表末尾的包展开处推导都会被使用。例如，考虑简单类型`Tuple`上的两个相似操作：
```cpp
template<typename... Types> class Tuple { };

template<typename... Types>
bool f1(Tuple<Types...>, Tuple<Types...>);

template<typename... Types1, typename... Types2>
bool f2(Tuple<Types1...>, Tuple<Types2...>);

void bar(Tuple<short, int, long> sv, Tuple<unsigned short, unsigned, unsigned long> uv)
{
  f1(sv, sv);	// OK: Types is deduced to {short int, long}
  f2(sv, sv);	// OK: Types1 is deduced to {short, int, long},
  				//     Types2 is deduced to {short, int, long}
  f1(sv, uv);	// ERROR: Types is deduced to {short, int, long} from the 1st arg, 
  				//        but to {unsigned short, unsigned, unsigned long} from the 2nd
  f2(sv, uv);	// OK: Types1 is deduced to {short, int, long},
  				//     Types2 is deduced to {unsigned short, unsigned, unsigned long}
}
```

`f1()`和`f2()`中，模板参数包都是将`Tuple`类型内嵌的包展开模式与调用实参所提供的`Tuple`类型进行比较，为一致的模板参数包推导出正确的值。函数`f1()`对两个函数参数使用相同的模板参数包`Types`，确保只有当两个函数调用实参有相同的`Tuple`特化体类型时，才能推导成功。而`f2()`则为每个函数参数各使用了一个参数包，因此两个调用参数可以不同——也就可以使用`Tuple`的两种特化体类型。

### 15.5.1 字面量操作符模板
字面量操作符模板的实参通过一种特殊的方式来确定。下面的例子进行了阐释：
```cpp
template<char...> int operator "" _B7();	// #1
...
int a = 121_B7;		// #2
```

这里，#2处的初始化器包含了一个用户定义的字面量（它会转换成对字面操作符模板的调用，使用的模板实参列表为`<'1','2','1'>`）。因此，字面量操作符的实现体可能如下：
```cpp
template <char... cs>
int operator"" _B7()
{
  std::array<char,sizeof...(cs)> chars{cs...};	// initialize array of passed chars
  for(char c : chars) {							// and use it (print it here)
    std::cout << "'" << c << "'";
  }
  std::cout << '\n';
  return ...;
}
```

它会为121.5_B7输出`'1' '2' '1' '.' '5'`。

请注意，仅在没有后缀的情况下仍然有效的数值字面量才支持此技术。例如：
```cpp
auto b = 01.3_B7;	// OK: deduces <'0','1','.','3'>
auto c = 0xFF00_B7;	// OK: deduces <'0','x','F','F','0','0'>
auto d = 0815_B7;	// ERROR: 8 is no valid octal literal 
auto e = hello_B7;	// ERROR: identifier hello_B7 is not defined
auto f = "hello"_B7;	// ERROR: literal operator _B7 does not match
```

参考P599节25.6对这一特性的应用：编译期计算整型字面量。

## 15.6 右值引用
C++11引入的右值引用促生了许多新技术，包括移动语义和完美转发。本节会描述右值引用与推导之间的交互。

### 15.6.1 引用折叠法则
开发者不允许直接声明“引用的引用”：
```cpp
int const& r = 42;
int const& & ref2ref = i;	// ERROR: reference to reference is invalid
```

然而，当通过模板参数替换、类型别名或是`decltype`结构构造类型时，“引用的引用”将被允许。例如：
```cpp
using RI = int&;
int i = 42;
RI r = i;
R const& rr = r;	// OK: rr has type int&
```

从诸如这种结构中确定类型的结果的规则就是众所周知的引用折叠法则。首先，任何应用于内部引用顶层的`const`或`volatile`限定符都会被舍弃（也就是说，只有内层引用的底层限定符才会被保留）。此后，这两种引用会根据表15.1推导出一个单一引用，这种推导方式可以总结为一句话：“如果某个引用是左值引用，那么结果也一定是左值引用，否则就是右值引用”。

<center>
	
| 内层引用 | 外层引用 | 结果引用 |
| - | - | - |
| & | & | & |
| & | && | & |
| && | & | & |
| && | && | && |
	
表15.1 引用折叠法则
</center>

另一个例子展示了这些规则的作用：
```cpp
using RCI = int const &;
RCI volatile&& r = 42;	// OK: r has type int const &;
using RRI = int&&;
RRI const&& rr = 42;	// OK: rr has type int&&
```

这里`volatile`被应用在`RCI`这一引用类型（`int const&`的别名）的顶层，因此会被丢弃掉。这一类型的顶层又放置了一个右值引用，但是由于底层类型是一个左值引用（左值引用在引用折叠规则中“更优先”），所以最终的类型保留为`int const&`（或者`RCI`类型、一个等价的别名）。类似地，`RRI`的顶层const会被丢弃，在右值引用类型上应用一个右值引用，最后的结果依然是一个右值引用类型（可以绑定到像42这样的右值上）。

### 15.6.2 转发引用
如同P91节6.1所介绍的那样，当函数参数是一个转发引用（函数模板参数中的右值引用）时，模板实参推导会呈现另一种表现形式。此时，模板实参推导不仅会考虑函数调用实参的类型，同时也会考虑该实参是左值还是右值。如果实参是一个左值，那么模板实参推导所确定的类型就是该实参类型的左值引用类型，引用折叠规则会确保所替换的参数可以成为一个左值引用。如果实参不是左值，那么模板参数所推导的类型就是实参类型，而替代的参数是该类型的右值引用。例如：
```cpp
template<typename T> void f(T&& p);	// p is a forwarding reference

void g()
{
  int i;
  int const j = 0;
  f(i);		// argument is an lvalue; deduces T to int& and
  			// parameter p has type int&
  f(j);		// argument is an lvalue; deduces T to int const& 
  			// parameter p has type int const&
  f(2);		// argument is an rvalue; deduces T to int
  			// parameter p has type int&&
}
```

在调用`f(i)`中，模板参数`T`被推导为`int&`，因为表达式`i`是一个类型为`int`的左值。`T`替换`int&`到参数类型`T&&`中需要引用折叠，这里我们使用规则`&`+`&&`->`&`来得出结论：参数类型为`int&`，如此就可以完美的接受`int`类型的左值。相对的，在调用`f(2)`中，实参`2`是一个右值，模板参数因此直接被推导为右值的类型（即`int`）。这里不需要进行引用折叠，其结果直接就是`int&&`（同样地，对实参来说这是一个合适的参数类型）。

当`T`被推导为一个引用类型时，对于模板的实例化来说有些有趣的效果。例如，使用类型`T`声明的局部变量，在用左值实例化后，会有一个引用类型，而此时它就需要一个初始化器：
```cpp
template<typename T> void f(T&&)	// p is a forwarding reference
{
  T x;	// for passed lvalues, x is a reference
  ...
}
```

这就意味着函数`f()`的定义需要很小心地使用类型`T`，或者函数模板本身根本不为左值参数生效。为了解决这一困境，`std::remove_reference`型别萃取常常被用来确保`x`不是一个引用：
```cpp
template<typename T> void f(T&&)	// p is a forwarding reference
{
  std::remove_reference_t<T> x;		// x is never a reference
  ...
}
```

### 15.6.3 完美转发
右值引用特殊的推导规则和引用折叠法则组合在一起使得编写一个接受任何实参的函数模板以及捕捉其显著的特性（其类型、以及它是一个左值还是右值）成为了可能。函数模板此后可以“转发”这一实参给另一个函数，诸如此例：
```cpp
class C {
  ...
};

void g(C&);
void g(C const&);
void g(C&&);

template<typename T>
void forwardToG(T&& x)
{
  g(static_cast<T&&>(x));	// forward x to g()
}

void foo()
{
  C v;
  C const c;
  forwardToG(v);	// eventually calls g(C&)
  forwardToG(c);	// eventually calls g(C const&)
  forwardToG(C());	// eventually calls g(C&&)
  forwardToG(std::move(v));	// eventually calls g(C&&)
}
```

上例所展示的技术被称为完美转发(perfect forwarding)，因为通过`forwardToG()`间接调用`g()`的效果与直接调用`g()`相同：没有额外的拷贝，选择的重载函数`g()`也一模一样。

`static_cast`的使用需要一些额外的解释。在每个`forwardToG()`的实例化体重，参数`x`要么是一个左值引用类型，要么是一个右值引用类型。而无论如何，表达式`x`本身一定是一个（其引用类型的）左值。`static_cast`会将`x`转换为其原始类型（不管左值还是右值）。类型`T&&`要么折叠成一个左值引用（如果原本的实参是一个左值，那么`T`就是一个左值引用），要么是一个右值引用（原本的实参就是一个右值），因此`static_cast`的结果就有了一致的类型，不论原本的实参是左值也好、右值也罢，如此，就实现了完美转发。

如P91节6.1所介绍的那样，C++标准库提供了一个函数模板`std::forward<>()`（在头文件`<utility>`中），它被用来取代`static_cast`进行完美转发。相比晦涩难懂的`static_cast`结构来说，使用这一模板对开发者来说更加表意，同时也防止了诸如少写了一个`&`所导致的错误。那么，上面的例子可以更为简明地写成这个样子：
```cpp
#include <utility>

template<typename T> void forwardToG(T&& x)
{
  g(std::forward<T>(x));	// forward x to g()
}
```

#### 可变模板的完美转发
完美转发与可变模板搭配在一起，可以让函数模板接受任意数量的函数调用实参并将它们逐一转发到另一个函数：
```cpp
template<typename... Ts> void forwardToG(Ts&&... xs)
{
  g(std::forward<Ts>(xs)...);	// forward all xs to g()
}
```

`forwardToG()`的实参会为参数包`Ts`分别被推导出合适的值（见P275节15.5），因此类型以及每个参数的左值性或右值性都会被捕获。包展开（见P201节12.4.1）在调用`g()`时会将每个实参都应用上述的完美转发技术进行转发。

尽管它拥有一个“完美转发”的名字，但实际上，从它不能捕获表达式所有感兴趣属性的意义上来说，完美转发实际上并不“完美”。例如，它无法区分左值是不是一个位域(bit-field)左值，也无法捕获表达式是否有特定的常量值。后者尤其在我们处理空指针常量时常常导致问题（它是一个整型类型、常量零值）。由于表达式常量值不会被完美转发所捕获，下例中的重载解析对直接调用`g()`和转发调用`g()`来说，表现上会有所区别：
```cpp
void g(int*);
void g(...);

template<typename T> void forwardToG(T&& x)
{
  g(std::forward<T>(x));	// forward x to g()
}

void foo()
{
  g(0);				// calls g(int*)
  forwardToG(0);	// eventually calls g(...)
}
```

这也是为什么使用`nullptr`(C++11所引入)取代空指针常量的另一个原因：
```cpp
g(nullptr);		// calls g(int*)
forwardToG(nullptr);	// eventually calls g(int*)
```

我们所有完美转发的例子都聚焦于传递的函数实参要如何保留其精准的类型以及它是一个左值或是右值。当转发函数调用的返回值给另一个函数时，也要面临同样的问题（类型和值的分类，对左值和右值的概括在附录B中进行了讨论）。C++11引入的`decltype`语法（在P298节15.10.2中描述），有一个有些冗长的惯用手法；
```cpp
template<typename... Ts>
auto forwardToG(Ts&&... xs) -> decltype(g(std::forward<Ts>(xs))
{
  return g(std::forward<Ts>(xs)...);	// forward all xs to g()
}
```

请注意，`return`语句的表达式被拷贝到了`decltype`类型里，因此返回表达式的准确类型会被计算出来。尾随返回类型被使用（即，函数名称前的`auto`占位符和指示返回类型的`->`），使得函数参数包`xs`也在`decltype`类型的作用域。该转发函数会“完美地”转发所有实参给`g()`，然后再“完美地”转发其返回值给调用者。

C++14引入了额外的特性来简化这一情景：
```cpp
template<typename... Ts>
decltype(auto) forwardToG(Ts&&... xs)
{
  return g(std::forward<Ts>(xs)...);	// forward all xs to g()
}
```

使用`decltype(auto)`做返回类型会指示编译器通过函数定义来推导返回类型。参见P296节15.10.1和P301节15.10.3。

### 15.6.4 推导惊奇之处
对完美转发来说，右值引用的特殊推导规则非常有用。然而，有时候它们可能会令人意外，这是因为函数模板通常会泛化函数签名中的类型，不会影响它所允许的参数是何种类型（左值或右值）。考虑下例：
```cpp
void int_lvalues(int&);		// accepts lvalues of type int
templte<typename T> void lvalues(T&);	// accepts lvalues of any type

void int_rvalues(int&&);	// accepts rvalues of type int
template<typename T> void anything(T&&);	// SURPRISE: accepts lvalues and
											// rvalues of any type
```

抽象出一个像`int_lvalues`那样的函数的开发者，可能会对函数模板`anything`可以接受左值而感到惊奇。幸运的是，只有当函数参数写成特定的模板参数`&&`的形式时（作为函数模板的一部分且命名的模板参数是由该函数模板所声明），才会应用这一推导行为。因此，下面这些例子的情形都不会应用推导规则：

```cpp
template<typename T>
class X
{
  public:
    X(X&&);		// X is not a template parameter
	X(T&&);		// this constructor is not a function template
	
	template<typename Other> X(X<U>&&);	// X<U> is not a template parameter
	template<typename U> X(U, T&&);		// T is a template parameter from 
										// an outer template
};
```

尽管模板推导规则有着这些令人惊奇的行为，在实践中，这种行为导致问题的情况并不经常出现。当出现问题时，你可以组合使用SFINAE（参考P129节8.4和P284节15.7）和诸如`std::enable_if`的型别萃取来约束模板只能接受右值：
```cpp
template<typename T>
typename std::enable_if<!std::is_lvalue_reference<T>::value>::type 
rvalues(T&&);	// accepts rvalue of any type
```

## 15.7 SFINAE(Substitution Failure Is Not An Error)
SFINAE(替换失败并非错误)原则在P129节8.4中介绍过，它是模板实参推导中在重载解析期间防止不相干的函数模板产生错误的关键人。

例如，考虑这样一对函数模板，它们从给定的容器或数组榨取起始的迭代器：
```cpp
template<typename T, unsigned N>
T* begin(T (&array)[N])
{
  return array;
}

template<typename Container>
typename Container::iterator begin(Container& c)
{
  return c.begin();
}

int main()
{
  std::vector<int> v;
  int a[10];
  
  ::begin(v);	// OK: only container begin() matches, because the first deduction fails
  ::begin(a);	// OK: only array begin() matches, because the second substitution fails
}
```

第一个`begin()`调用的实参是`std::vector<int>`，它试图为两个`begin()`函数模板做模板实参推导：
- 对数组`begin()`的模板实参推导失败了，因为`std::vector`不是一个数组，所以被忽略。
- 模板实参推导对容器`begin`成功了，`Container`被推导成`std::vector<int>`，因此函数模板可以被实例化，也可以被调用。

第二个`begin()`调用的实参是一个数组，也会部分失败：
- 对数组`begin()`推导成功，`T`被推导为`int`，`N`被推导为`10`。
- 对容器`begin()`来说，推导需要将`Container`替换为`int[10]`，这本身没有问题，但是如此产生的返回类型`Container::iterator`却是无效的（因为数组类型并没有嵌套的名为`iterator`的类型）。在其他上下文中，试图访问一个本不存在的嵌套类型会立即导致一个编译期错误。而在模板实参的替换中，SFINAE会将这种错误转换成推导失败，并且不再将这一函数模板纳入考虑。因此，第二个`begin()`候选会被忽略，第一个`begin()`函数模板的特化体会被调用。

### 15.7.1 即时上下文
SFINAE防止了那些试图形成的无效类型或表达式，包括因歧义或非法访问控制所产生的错误，它们发生在函数模板替换的即时上下文中。比起定义“函数模板替换的即时上下文”，定义“不在该上下文中”可能更为容易。具体来说，在函数模板替换过程中，为了推导而发生的下面这些实例化期间的事，都不在函数模板替换的即时上下文中：
- 类模板的定义（即，类模板本身以及其基类列表）
- 函数模板的定义（即，函数模板本身，对构造函数来说，是其构造初始化器）
- 变量模板初始化
- 默认实参
- 默认成员初始化
- 异常规范(exception specification)

此外，任何由替换过程所触发的特殊成员函数的隐式定义也不属于替换的即时上下文。除此之外，尽属即时上下文。

因此，如果在替换函数模板声明的模板参数时需要类模板实例化（因为该类被引用了），则实例化过程产生的错误并不在函数模板替换的即时上下文中，因此它会产生一个真正的错误（即使另一个函数模板可以无错误地匹配上）。例如：
```cpp
template<typename T>
class Array {
  public:
    using iterator = T*;
};

template<typename T>
void f(Array<T>::iterator first, Array<T>::iterator last);

template<typename T>
void f(T*, T*);

int main()
{
  f<int&>(0, 0);	// ERROR: substituting int& for T in the first function template
  					// instantiates Array<int&>, which then fails
}
```

本例与前例最主要的差别在于失败发生的位置。前例中，失败发生在形成一个类型为`typename Container::iterator`之时，它在`begin()`函数模板替换的即时上下文中。而本例中，失败发生在`Array<int&>`的实例化体中，尽管它是由函数模板上下文所触发，但实际上是发生在类模板`Array`的上下文中。因此，SFINAE原则并不适用，编译器会产生一个错误。

这里有一个C++14的例子——基于推导返回类型（P296节15.10.1）——在函数模板定义的实例化时导致错误：
```cpp
template<typename T> auto f(T p) {
  return p->m;
}

int f(...);

template<typename T> auto g(T p) -> decltype(f(p));

int main()
{
  g(42);
}
```

调用`g(42)`会推导`T`为`int`。这使得`g()`声明的替换需要我们去确定`f(p)`的类型（`p`现在已知为类型`int`），然后再确定`f()`的返回类型。`f()`有两个候选者。非模板候选者是匹配的，但它不是一个良选，这是因为它匹配的是一个省略型参数。不幸的是，模板候选者有一个推导的返回类型，因而我们必须实例化它的定义来确定该返回类型。该实例化会因为`p->m`无效而失败（因为`p`是`int`），并且该错误发生在替换上下文之外（因为它在随后的函数定义实例化体中），这就导致本次失败会产生一个错误。为此，我们推荐在可以容易地显式化指定返回类型时，避免使用推导返回类型。

SFINAE设计之初，是旨在消除由函数模板重载所带来的因非意图匹配而产生的奇怪错误，正如容器`begin`这一例子。然而，探测无效表达式或类型的能力可以实现卓越的编译时技巧，以允许我们判断某个特定的语法是否是合法的。这些技巧将在P416节19.4中进行讨论。

在P424节19.4.4中，有一个特别的例子：让型别萃取SFINAE-friendly来避免及时上下文所产生的问题。

## 15.8 推导的限制
模板实参推导是一个强大的特性，对于大部分函数模板调用来说它消除了显式地指定模板实参的必要性，并且还使能了函数模板重载（见P15节1.5）和类模板偏特化（见P347节16.4）。然而，开发者可能会在使用模板时遇到一些使用上的限制，这些限制会在本节中进行讨论。

### 15.8.1 合法的实参转换
通常来说，模板推导会尝试去找到一个函数模板参数的替换，以使得参数化类型P与类型A等同。然而，当无法达成这一条件，而P在推导上下文中又包含一个模板参数时，下面的一些差别也是可以忍受的：
- 如果原始的参数使用了引用声明，被替换的P类型相比A类型可以有进一步的`const/volatile`限定
- 如果A类型是一个指针或是类成员指针类型，它可以通过限定转换（换句话说，就是一种增加`const`或/和`volatile`限定符的转换）来转换成一个替换的P类型。
- 除非推导发生于转换操作符模板，替代的P类型可以是A类型的基类或是指向其基类的指针。例如：

```cpp
template<typename T>
class B {
};

template<typename T>
class D : public B<T> {
};

template<typename T> void f(B<T>*);

void g(D<long> dl) 
{
  f(&dl);	// deduction succeeds with T substituted with long
}
```

如果P在推导上下文中不包含模板参数，那么所有的隐式转换都是合法的。例如：
```cpp
template<typename T> int f(T, typename T::X);

struct V {
  V();
  struct X {
    X(double);
  };
}v;
int r = f(v, 7.0);	// OK: T is deduced to V through the first parameter,
					// which causes the second parameter to have type V::X
					// which can be constructed from a double value
```

仅当不可能完全匹配时才考虑宽松的匹配要求。即使有了这些附加的转换，推导也仅仅会在可以找到满足A类型到P类型的合适替换才会成功。

请注意，这些规则的范围非常狭窄，忽略了（例如）可应用于函数实参以使调用成功的各种转换。例如，考虑下面的`max()`函数模板调用，该模板在P269节15.1介绍：
```cpp
std::string maxWithHello(std::string s)
{
  return ::max(s, "hello");
}
```

这里，模板实参推导根据第一个实参会把`T`推导为`std::string`，而第二个实参会把`T`推导为`char[6]`，所以模板实参推导会失败，这是因为两个参数使用的是同一个模板实参。这种失败可能有些令人诧异，因为字符串字面量`"hello"`可以被隐式转换成`std::string`，并且调用`::max<std::string>(s, "helloa")`是可行的。

可能更令人惊讶的是：当两个实参有着从公共基类继承下来的不同的类类型时，推导并不会将公共基类作为推导类型的候选者进行考虑。可参考P7节1.2关于这一议题的讨论以及可行的解决方案。

### 15.8.2 类模板实参
C++17之前，模板实参推导仅仅应用于函数和成员函数模板。特别地，类模板的实参不会根据其中某一个构造器的实参来进行推导。例如：
```cpp
template<typename T>
class S {
  public:
    S(T b) : a(b) {}
  private:
    T a;
};
S x(12);	// ERROR before C++17: the class template parameter T was not deduced from
			// the constructor call argument 12
```

这一限制在C++17中被解除——参考P313节15.12。

### 15.8.3 默认调用实参
默认函数调用实参可以再函数模板中指定，正如普通函数所操作的那样：
```cpp
template<typename T>
void init(T* loc, T const& val = T())
{
  *loc = val;
}
```

事实上，如示例所展示，默认函数调用实参可以依赖于模板参数。这种依赖型默认实参仅在没有提供显式的实参时才会被实例化。这一原则是的下面的例子依然合法：
```cpp
class S {
  public:
    S(int, int);
};

S s(0, 0);

int main()
{
  init(&s, S(7,42));	// T() is invalid for T = S, but the default
  						// call argument T() needs no instantiation
						// because  an explicit argument is given
}
```

即使当默认调用实参并非依赖型，它也无法被用于推导模板实参。这意味着在C++中，下面的写法是非法的：
```cpp
template<typename T>
void f(T x = 42)
{
}

int main()
{
  f<int>();	// OK: T = int
  f();		// ERROR: cannot deduce T from default call argument
}
```

### 15.8.4 异常规范
与默认调用实参一样，异常规范也仅仅在它们被需要时才会实例化。这意味着他们不会参与模板实参推导。例如：
```cpp
template<typename T>
void f(T, int) noexcept(nonexistent(T()));	// #1

template<typename T>
void f(T, ...);	// #2 (C-style vararg function)

void test(int i)
{
  f(i, i);	// ERROR: chooses #1, but the expression nonexistent(T()) is ill-formed
}
```

函数标记#1处的`noexcept`规范尝试调用一个`nonexistent`函数。通常来说，函数模板声明中这样的错误会直接触发模板实参推导失败（SFINAE），然后再通过选择标记#2处的函数使用省略型参数匹配是重载解析中最差的匹配，参考附录C）来匹配调用`f(i, i)`。然而，由于异常规范并没有参与到模板实参推导，重载解析还是会选择标记#1，这就导致当`noexcept`规范在随后实例化时，程序格式错误。

相同的规则适用于列出潜在异常类型的异常规范：
```cpp
template<typename T>
void g(T, int) throw(typename T::Nonexistent);	// #1

template<typename T>
void g(T, ...);									// #2

void test(int i)
{
  g(i, i);	// ERROR: chooses #1, but the type T::Nonexistent is ill-formed
}
```

然而，这些“动态的”异常规范自C++11起就不再推荐使用(deprecated)，它们在C++17中被移除。

## 15.9 显式的函数模板实参
当函数模板实参无法被推导时，通过函数模板名后尾随的方式显式地指定亦是可行的。例如：
```cpp
template<typename T> T default_value()
{
  return T{};
}

int main()
{
  return default_value<int>();
}
```

对可推导的模板参数来说这也是可行的：
```cpp
template<typename T> void compute(T p)
{
  ...
}

int main()
{
  compute<double>(2);
}
```

一旦一个模板实参被显式指定了，其对应的参数就不会再被推导。顺带地，对函数调用参数将允许进行类型转换（对推导调用来说这是不可行的）。上例中，实参`2`在`compute<double>(2)`调用中会被隐式转换成`double`。

显式指定模板实参的一部分亦是可行的。然而，显示指定的那些必须始终得按模板参数从左到右的顺序。因此，那些不能被推导的（或者最可能被显式指定的）参数应该放在最前面。例如：
```cpp
template<typename Out, typename In>
Out convert(In p)
{
  ...
}

int main()
{
  auto x = convert<double>(42);	// the type of parameter ps is deduced,
  								// but the return type is explicitly specified
}
```

有时候，通过指定一个空模板实参列表对于确保所选的函数是模板实例也是有用的，此时模板实参还是会进行推导：
```cpp
int f(int);		// #1
template<typename T> T f(T);	// #2

int main() {
  auto x = f(42);		// calls #1
  auto y = f<>(42);		// calls #2
}
```

这里`f(42)`会选择非模板函数，因为对于重载解析来说，相比函数模板，它更倾向于选择普通的函数（如果两者是等价的）。然而，对于`f<>(42)`来说，模板实参列表的存在打破了这一规则，非模板函数不再可选（即使没有指定实际的模板实参）。

在友元函数声明的上下文中，显式模板实参列表的存在会产生一个有趣的效果。考虑下面的例子：
```cpp
void f();
template<typename> void f();
namespace N {
  class C {
    friend int f();			// OK
	friend int f<>();		// ERROR: return type conflict
  };
}
```

当使用普通的标识符命名一个友元函数时，该函数仅仅会在最近一层的封闭作用域内查找，并且如果它没有被找到的话，就会在该作用域内声明一个新的实体（但它会保留“不可见性”，除非通过ADL查找；参考P220节13.2.2）。这就是我们第一个友元声明：在`N`作用域内没有`f`的声明，所以会声明一个不可见的`N::f()`。

然而，当标识符尾随模板实参列表来命名友元函数时，模板必须在那一刻对普通查找是可见的，普通查找会向上搜索任意层作用域（根据其所需要）。因此，我们第二个声明会找到全局的函数模板`f()`，但是编译器会提出一个错误：返回类型不匹配（由于没有执行ADL，故前一个友元函数的声明会被忽略）。

显式指定的模板实参使用SFINAE法则来替换：如果在某个函数模板的替换的即时上下文中出现了错误，那么它就会被丢弃，但是其他模板依然可能会成功。例如：
```cpp
template<typename T> typename T::EType f();	// #1
template<typename T> T f();					// #2

int main() {
  auto x = f<int*>();
}
```

这里，#1处候选者在`int*`替换`T`时会失败，但是#2处会成功，因此也就会选择#2这一候选。事实上，如果在替换之后仅余一个候选者，那么带有显式模板实参的函数模板名称看起来非常像一个普通的函数名称，包括在许多情况下退化为指向函数的指针类型。也就是说，替换上面的`main()`为：
```cpp
int main() {
  auto x = f<int*>;	// OK: x is a pointer to function
}
```

这会产生合法的编译单元。然而，下面的例子中：
```cpp
template<typename T> void f(T);
template<typename T> void f(T, T);

int main() {
  auto x = f<int*>;		// ERROR: there are two possible f<int*> here
}
```

这种用法就是非法的，因为`f<int*>`并没有标识着某一个单一的函数。

可变函数模板也可以使用显式模板实参：
```cpp
template<typename ...Ts> void f(Ts... ps);

int main() {
  f<double, double, int>(1, 2, 3);	// OK: 1 and 2 are converted to double
}
```

有趣的是，包可以被部分显式指定、部分显式推导：
```cpp
template<typename ...Ts> void f(Ts... ps);

int main() {
  f<double, int>(1, 2, 3);	// OK: the template arguments are <double, int, int>
}
```

## 15.10 初始化器和表达式推导
C++11引入了声明这样一种变量的能力：其类型是从初始化器所推导的。C++11也提供了一种机制来表示某个命名实体（变量或函数）或是表达式的类型。这些机制十分易用，C++14和C++17对这一主题又进行了补充。

### 15.10.1 auto类型指示符
`auto`类型指示符在很多地方有着用武之地（主要是命名空间作用域和局部作用域），它会根据变量的初始化器推导变量类型。此时，`auto`被称作为一个占位符类型（另一个占位符类型是`decltype(auto)`），我们会在P298节15.10.2中对它进行描述。例如：
```cpp
template<typename Container>
void useContainer(Container const& container)
{
  auto pos = container.begin();
  while(pos != container.end()) {
    auto& element = *pos++;
	... // operate on the element 
  }
}
```

本例的两个`auto`的使用规避了书写两个又臭又长的类型名称：容器的迭代器类型和迭代器的值类型：
```cpp
typename Container::const_iterator pos = container.begin();
...
typename std::iterator_traits<typename Container::iterator>::reference  element = *pos++;
```

`auto`的推导机制与模板实参推导相同。类型指示符`auto`取代模板类型参数`T`，然后推导继续进行，就好像变量是一个函数参数，而其初始化器是相应的函数实参。对例子中第一个`auto`来说，对应的情况如下：
```cpp
template<typename T> void deducePos(T pos);
deducePos(container.begin());
```

`T`是`auto`要推导的类型。这样做的直接后果之一是，类型为`auto`的变量永远不会是引用类型。第二个`auto`使用了`auto&`来阐释了如何产生一个推导类型的引用。它的推导与下面的函数模板和调用等价：
```cpp
template<typename T> deduceElement(T& element);
deduceElement(*pos++);
```

这里，`element`永远是引用类型，它的初始化器无法产生一个临时对象。

组合`auto`与右值引用亦是可行的，但是这样做就变成了一个转发引用，因为`auto&& r = ...;`的推导模型基于这样一个函数模板：
```cpp
template<typename T> void f(T&& fr);	// auto replaced by template parameter T
```

这就解释了下面的例子：
```cpp
int x;
auto&& rr = 42;	// OK: rvalue reference binds to an rvalue (auto = int)
auto&& lr = x;	// Also OK: auto = int& and reference collapsing makes
				// 			lr an lvalue reference
```

在泛型代码中这一技巧经常被用来绑定函数或操作符调用的结果（它们的值类别（左值或是右值）并不知晓），而无需拷贝它们的结果。例如，常常推荐这样的方式在循环中声明迭代值：
```cpp
template<typename Container> void g(Container c) {
  for(auto&& x : c) {
    ...
  }
}
```

这里我们不知道容器迭代器接口的签名，但是使用`auto&&`可以让我们确信在迭代时不会引入额外的值拷贝。如果需要完美转发边界值，那么`std::forward<T>()`可以像往常那样对变量使用。这使能了一种“延迟的”完美转发。可以参考P167节11.3的示例。

除了引用，我们还可以组合使用`auto`指示符来让某个变量拥有`const`，成为指针或是成员指针等等，但是`auto`必须是其声明的“主”类型。它不能嵌套在模板实参或类型指示符后面的声明符中作为一部分而存在。下面的例子阐释了这些可能性：
```cpp
template<typename T> struct X { T const m; };
auto const N = 400u;	// OK: constant of type unsigned int
auto* gp = (void*)nullptr;	// OK: gp has type void*
auto const S::*pm = &X<int>::m;		// OK: pm has type int const X<int>::*
X<auto> xa = X<int>();			// ERROR: auto in template argument
int const auto::*pm2 = &X<int>::m;	// ERROR: auto is part of the "declarator"
```

关于为什么C++不支持上例中所有的场景，并没有什么技术上的原因，但是C++委员会认为它所带来的额外实现成本以及潜在的滥用性都超出了它的收益。

为了避免同时搞晕开发者和编译器，在C++11中古式的`auto`用法（作为一个存储类型指示符而存在）不再被允许（今后也一样）：
```cpp
int g() {
  auto int r = 24;		// valid in C++03 but invalid in C++11
  return r;
}
```

`auto`的古式用法（继承自C语言）一直是冗余的。大多数编译器通常可以将该用途与占位符区别开来（尽管它们不必如此），以提供从旧C++代码到新C++代码的过渡途径。只不过，`auto`的古式用法在实践中非常罕见。

#### 返回类型推导
C++14新增了另一个推导`auto`占位符的情景，它出现于函数返回类型。例如：
```cpp
auto f() { return 42; }
```

定义了一个返回类型为`int`的函数（`42`的类型）。它也可以使用尾缀返回类型语法来表示：
```cpp
auto f() -> auto { return 42; }
```

后者的第一个`auto`宣布了尾缀返回类型，第二个`auto`是一个推导的占位符类型。只不过，没有什么理由去支持更啰嗦的语法。

对lambda来说有着相同的默认机制存在：如果没有显式地指定返回类型，lambda表达式返回的类型会按照`auto`来推导：
```cpp
auto lm = [] (int x) { return f(x); };
		// same as: [] (int x) -> auto { return f(x); };
```

函数可以脱离定义而单独声明。对于返回类型需要推导的情景也是一样：
```cpp
auto f();	// forward declaration
auto f() { return 42; }
```

但是，在这种情况下，前向声明的用法非常有限，因为在使用函数的任何位置，该定义都必须可见。也许令人惊讶的是，提供带有“已解决的”返回类型的前向声明是无效的。例如：
```cpp
int known();
auto known() { return 42; }	// ERROR: incompatible return type
```

通常，由于风格上的偏爱，仅在将成员函数定义移到类定义外部时，前向声明推导的返回类型的函数才有作用：
```cpp
struct S {
  auto f();		// the definition will follow the class definition
};
auto S::f() { return 42; }
```

#### 可推导的非类型参数
在C++17之前，非类型参数只能通过指定的类型来声明。然而，这一类型可以是一个模板参数类型。例如：
```cpp
template<typename T, T V> struct S;
S<int, 42>* ps;
```

在本例中，需要指定非类型模板实参的类型——即指定`int`和42，这可能很乏味。因此，C++17增加了声明非类型模板参数的能力，这些参数的实际类型是从相应的模板实参推导出来的。它们如下所声明：
```cpp
template<auto V> struct S;
```

于是就可以用`S<42>* ps;`。这里`S<42>`的类型`V`会被推导成`int`，这是因为`42`的类型是`int`。如果我们写作`S<42u>`，那么`V`的类型就会被推导成`unsigned int`(参考P294节15.10.1了解推导`auto`类型指示符的更多细节)。

请注意，对非类型模板参数类型的一般约束仍然有效。例如：
```cpp
S<3.14>* pd;	// ERROR: floating-point nontype argument
```

具有这种可推导的非类型参数的模板定义通常还需要表示相应参数的实际类型。这可以通过`decltype`语法来完成（参考P298节15.10.2）。例如：
```cpp
template<auto V> struct Value {
  using ArgType = decltype(V);
};
```

`auto`非类型模板参数在参数化类成员的模板时也很有用。例如：
```cpp
template<typename> struct PMClassT;
template<typename C, typename M> struct PMClassT<M C::*> {
	using Type = C;
};
template<typename PM> using PMClass = typename PMClassT<PM>::Type;

template<auto PMD> struct CounterHandle {
  PMClass<decltype(PMD)>& c;
  CounterHandle(PMClass<decltype(PMD)>& c) : c(c) {
  }
  void incr() {
    ++(c.*PMD);
  }
};

struct S {
  int i;
};

int main() {
  S s{41};
  CounterHandle<&S::i> h(s);
  h.incr();	// increases s.i
}
```

这里我们使用了一个辅助类模板`PMClassT`的一个偏特化（参考P347节16.4）来借由成员指针类型追溯到它的“父”类类型。有了`auto`模板参数，我们只需要指定成员指针常量`&S::i`作为模板实参。在C++17之前，我们还得指定一个成员指针类型，如`OldCounterHandle<int S::*, &S::i>`，看起来很笨重很冗余。

如你所愿，这一特性也可以为非类型参数包使用：
```cpp
template<auto... VS> struct Values {
};
Values<1, 2, 3> beginning;
Values<1, 'x', nullptr> triplet;
```

`triplet`实例展示了每个非类型参数都可以被单独地推导。与多重可变声明场景（参考P303节15.10.4）不同的是，这里不需要每个推导都是相同的。

如果我们想强制每个非类型模板参数都相同，也是可以实现的：
```cpp
template<auto V1, decltype(V1)... VRest> struct 
HomogeneousValues {
};
```

然而，此场景中模板实参列表不能为空。

可以参考P50节3.4中一个使用了`auto`作为模板参数类型的完整例子。

### 15.10.2 用decltype表示表达式的类型
