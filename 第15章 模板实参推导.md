# 第15章 模板实参推导
如果为每个函数模板都显式地指定模板实参，那么很快代码就会显得又笨又重（比如：`concat<std::string, int>(s, 3)`）。幸运的是，C++编译器常常可以自动判断模板实参类型，这是通过一个十分高效的过程——模板实参推导——来完成的。

本章中我们将详述模板实参推导这一过程的细节。和C++其他的知识一样，大多数规则通常会产生一个直观的结果，模板实参推导也不例外。此外，对这一章的深刻理解可以使我们以后避免遇到出人意料的情景。

尽管模板实参推导是为了简化函数模板的调用而首先开发的，但是自那以后，它已扩展到适用于其他几种用途，包括从其初始值设定项(initializer)确定变量的类型。

## 15.1 推导过程
基本的推导过程会比较“函数调用的实参类型”与“函数模板对应位置的参数化类型”，然后针对要被推导的一到多个参数，分别尝试去推断一个正确的替换项。每个实参-参数对都会独立分析，并且如果最终得出的结论产生矛盾(differ)，那么推导过程就失败了。

考虑下面的例子：
```cpp
template<typename T>
T max(T a, T b)
{
  return b < a ? a : b;
}

auto g = max(1, 1.0);
```

这里第一个调用实参的类型是`int`，因此我们原生的`max()`模板的参数`T`会被姑且推导成`int`。然而，第二个调用实参是`double`类型，基于此，`T`会被推导为`double`：这就与前一个推导产生了矛盾。注意：我们称之为“推导过程失败”，而不是“程序非法”。毕竟，可能对于另一个名为`max`（函数模板可以像普通函数那样被重载；参考P15节1.5和第16章）的模板来说推导过程可能是成功的。

即使所有被推导的模板实参都可以一致地确定（即不产生矛盾），推导过程仍然可能会失败。这种情况发生于：在函数声明中，进行替换的模板实参可能会导致无效的结构。请看下例：

```cpp
template<typename T>
typename T::ElementT at(T a, int i)
{
  return a[i];
}

void f(int* p)
{
  int x = at(p, 7);
}
```

这里`T`被推导为`int*`(`T`出现的地方只有一种参数类型，因此显然不会有解析矛盾)。然而，将`T`替换为`int*`在C++中对于返回类型`T::ElementT`显然是非法的，因此推导就失败了。

我们仍然需要探索实参-参数匹配如何进行。我们会使用下面的概念来进行描述：匹配类型A（来自实参的类型）和参数化类型P（来自参数的声明）。如果被声明的参数是一个引用，那么P就是所引用的类型，A仍然是实参的类型。如果声明的参数不是引用，那么P就是声明的参数类型，而A类型的获取则会经过数组和函数类型到指针类型的退化，并且会忽略顶层const和volatile限定符。例如：

```cpp
template<typename T> void f(T);		// parameterized type P is T
template<typename T> void g(T&);	// parameterized type P is also T

double arr[20];
int const seven = 7;

f(arr);		// nonreference parameter: 	T is double*
g(arr);		// reference parameter:		T is double[20]
f(seven);	// nonreference parameter: 	T is int
g(seven);	// reference parameter:		T is int const
f(7);		// nonreference parameter:	T is int
g(7);		// reference parameter:		T is int => ERROR: can't pass 7 to int&
```

对调用`f(arr)`来说，`arr`数组类型会退化为类型`double*`，作为推导的`T`的类型。在`f(seven)`中`const`限定符被忽略了，因此T被推导为`int`。相反地，`g(x)`推导`T`为类型`double[20]`(没有发生退化)。与此类似地，`g(seven)`有一个类型为`int const`的左值实参，并且因为在匹配引用参数时，`const`和`volatile`限定符不会被去除，`T`会被推导为`int const`。然而，注意由于`g(7)`想要推导`T`为`int`（因为非类的右值表达式永远不会有`const`或`volatile`限定类型），这一调用会失败，因为实参`7`无法作为一个`int&`类型的参数被传递。

引用类型的参数不会退化这一事实，对于参数为字符串字面量的场合来说可能会令人惊讶。重新审视我们的使用引用类型的`max()`模板声明：
```cpp
template<typename T>
T const& max(T const& a, T const& b);
```

对于表达式`max("Apple", "Pie")`来说，`T`被推断为`char const*`看起来很合理。然而，实际上`Apple`的类型是`char const[6]`、`Pie`的类型是`char const[4]`。这里并不会进行数组到指针的退化（因为推导涉及了引用类型的参数），因此想要推导成功，`T`必须既得是`char[6]`又得是`char[4]`。显然，这绝无可能。可以参考P115节7.4中对于如何处理这一场景的一个探讨。

## 15.2 推导上下文
比`T`复杂得多的参数化类型也可以匹配一个给定的实参类型。这里有一些相当基础的例子：
```cpp
template<typename T>
void f1(T*);

template<typename E, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1 (T2::*)(T3*));

class S {
  public:
    void f(double*);
};

void g(int*** ppp)
{
  bool b[42];
  f1(ppp);		// deduces T to be int**
  f2(b);		// deduces E to be bool and N to be 42
  f3(&S::f);	// deduces T1 = void, T2 = S, and T3 = double
}
```

复杂的类型声明都是用比它更基本的结构（例如指针、引用、数组、函数声明；成员指针声明；模板ID等）来组成的，匹配过程从最顶层结构开始处理，一路递归其各种组成元素。可以说基于这一方法，大部分类型声明结构都可以进行匹配，而这些结构也被称为“推导上下文“。然而，有些结构不能作为推导上下文。例如：
- 受限的类型名称。例如，形如`Q<T>::X`的类型名称永远不会用来推导模板参数`T`。
- 除了非类型参数之外，模板参数还包含其他成分的非类型表达式。例如，形如`S<I+1>`的类型名称永远不会用于推导`I`。再比如，`T`也不会通过匹配形如`int(&)[sizeof(S<T>)]`类型的参数来推导。这些限制合乎常理，因为通常来说，推导并不是唯一的（甚至不一定是有限的），尽管有时候会很容易忽略这些受限的类型名称。此外，一个不能推导的上下文并不会自动地表明：所对应的程序有错误，或者甚至前面分析过的参数不能再次进行类型推导。为了阐释这一事实，考虑下面这个更为错综复杂的例子：
```cpp
template<int N>
class X {
  public:
    using I = int;
	void f(int) {}
};

template<int N>
void fppm(void (X<N>::*p)(typename X<N>::I));

int main()
{
  fppm(&X<33>::f);		// fine: N deduced to be 33
}
```

在函数模板`fppm()`中，子结构`X<N>::I`是一个不可推导的上下文。然而，具有成员指针类型（即`X<N>::*p`）的成员类型部分`X<N>`是一个可推导上下文。于是，可以根据这个可推导上下文获得参数`N`，然后把`N`放入不可推导的上下文`X<N>::I`，就能获得与实参`＆X<33>::f`相配的类型。因此基于这个实参-参数对的推导就是成功的。

相反，对于完全依赖推导上下文的参数类型来说，有可能会产生推导矛盾。例如，假设我们已恰当地声明过类模板`X`和`Y`：
```cpp
template<typename T>
void f(X<Y<T>, Y<T>>);

void g()
{
  f(X<Y<int>, Y<int>>());	// OK
  f(X<Y<int>, Y<char>>());	// ERROR: deduction fails
}
```

第二个调用的问题在于两个实参对于参数`T`的推导是不同的，而这显然是无效的（两种情景里，函数调用实参都是一个临时的对象，这一对象借由调用类模板`X`的默认构造器而获得）。

## 15.3 特殊的推导情况
存在一些特殊的情况：用于推导的实参-参数对（A, P）并不是分别来自于函数调用的实参和函数模板的参数。第一种情况出现在取函数模板地址的时候。此时，P是函数模板声明的参数化类型（即下面`f`的类型），而A是被赋值（或者初始化）的指针（即下面的`pf`）所代表的函数类型。例如：
```cpp
template<typename T>
void f(T, T);

void (*pf)(char,char) = &f;
```

在本例中，P是`void(T, T)`，而A是`void(char, char)`。推导随着`T`被`char`替换而成功，而`pf`用特化体`f<char>`的地址进行初始化。

类似地，函数类型在一些其他特殊情况下也被P和A所使用：
- 确定重载函数模板之间的偏序
- 将某个显式特化体与某个函数模板匹配
- 将某个显式实例化体与某个模板匹配
- 将某个友元函数模板特化体与某个模板匹配
- 将占位(replacement)`operator delete`或是`operator delete[]`与对应的占位`operator new`或`operator new[]`模板匹配。

这些话题中的部分内容，以及类模板偏特化中模板实参推导的使用，会在第16章中进行展开。

另一种特殊情况和转型运算符模板一起出现。例如：
```cpp
class S {
  public:
    template<typename T> operator T&();
};
```

在本例中，实参-参数对(P, A)的获取涉及到我们试图进行转型的实参和转换运算符的返回类型。下面的代码清楚地说明了这种情况：
```cpp
void f(int (&)[20]);

void g(S s)
{
  f(s);
}
```

这里，我们试图把`S`转型为`int(&)[20]`，因此，类型A为`int[20]`，而类型P为`T`。当`T`被`int[20]`替换时，推导就是成功的。

最后，对于`auto`占位类型来说，也需要一些特殊的对待。这会在P303节15.10.4中进行讨论。

## 15.4 初始化列表(initializer list)
当函数调用的实参是一个初始化列表时，该实参是没有一个特定的类型的，因此通常来说，对于给定实参-参数对(A, P)，不会进行任何推导，因为这里并不存在A。例如：
```cpp
#include <initializer_list>

template<typename T> void f(T p);

int main() {
  f({1, 2, 3});		// ERROR: cannot deduce T from a braced list
}
```

然而，如果参数类型P（在移除引用、顶层const和volatile限定符后）与`std::initializer_list<P'>`等价（对某些类型`P'`来说有一个可推导的模式(deducible pattern))，推导过程会将初始化列表的每个元素类型与`P'`进行比较，只有在所有的元素类型都有相同的类型时，推导才是成功的。
*deduce/initlist.cpp*
```cpp
#include <initializer_list>

template<typename T> void f(std::initializer_list<T>);

int main()
{
	f({2,3,5,7,9});						// OK: T is deduced to int
	f({'a', 'e', 'i', 'o', 'u', 42});	// ERROR: T deduced to both char and int
}
```

类似地，如果参数类型`P`是一个`P'`类型数组的引用（有一个可推导的模式），推导过程也会将初始化列表的每个元素的类型与`P'`进行比较，当且仅当所有元素都有相同的类型时，推导成功。此外，如果（数组）边界有一个可推导模式（即，仅命名一个非类型模板参数），那么该边界会被推导为初始化列表中元素的数量。

## 15.5 参数包
推导过程会逐一匹配每个实参到每个参数来确定模板实参的值。然而在对可变模板进行模板实参推导时，参数和实参之间1比1的关系就被打破了，这是因为一个参数包可以匹配多个实参。在本例中，同一个参数包(P)被匹配到了多个实参(A)，并且每次匹配都会为P中的任何模板参数包产生附加值：

```cpp
template<typename First, typename... Rest>
void f(First first, Rest... rest);

void g(int i, double j, int* k)
{
  f(i, j, k);	// deduces First to int, Rest to {double, int*}
}
```

此处对首个函数参数的推导很简单，毕竟它并没有卷入任何参数包。第二个函数参数，`rest`，是一个函数参数包。它的类型是一个包展开(`Rest...`)，其模式为类型`Rest`：该模式用作P，与第二和第三调用参数的类型A进行比较。当匹配第一个A时（类型`double`），模板参数包`Rest`的第一个值被推导为`double`。类似地，与第二个A进行匹配时，模板参数包`Rest`的第二个值被推导为`int*`。因此，推导确定了参数包`Rest`的值序列为`{double, int*}`。替换这一推导以及第一个函数参数的结果就可以得到函数类型`void(int, double, int*)`，它与函数调用的每个实参类型相匹配。

由于函数参数包使用了展开的模式进行比较，因此该模式可以任意复杂，并且可以从每种实参类型中确定多个模板参数和参数包的值。考虑下面的函数`h1()`和`h2()`的推导行为：
```cpp
template<typename T, typename U> class pair { };

template<typename T, typename... Rest>
void h1(pair<T, Rest> const&...);
template<typename... Ts, typename... Rest>
void h2(pair<Ts, Rest> const&...);

void foo(pair<int, float> pif, pair<int, double> pid, pair<double, double> pdd) 
{
  h1(pif, pid);	// OK: deduces T to int, Rest to {float, double}
  h2(pif, pid);	// OK: deduces Ts to {int, int}, Rest to {float, double}
  h1(pif, pdd);	// ERROR: T deduced to int from the 1st arg, but to double from the 2nd
  h2(pif, pdd);	// OK: deduces Ts to {int, double}, Rest to {float, double}
}
```

对`h1()`和`h2()`来说，P是为推导的每个实参类型调整成了非受限引用版本（分别为`pair<T, Rest>`和`pair<Ts, Rest>`）的引用类型。由于所有的参数和实参都是类模板`pair`的特化体，因此将比较模板参数。对`h1()`来说，首个模板实参`T`并非参数包，因此它的值会为每个实参所独立推导。如果推导的结果出现矛盾（正如第二个`h1`调用那样），推导就失败了。对第二个在`h1()`和`h2()`的`pair`模板实参`Rest`、以及`h2()`的第一个模板实参`Ts`来说，推导会根据A的每个实参类型来确定模板参数包的值。

参数包的推导不限于其中“实参-参数对”来自调用参数的函数参数包。实际上，在函数参数列表或模板参数列表末尾的包展开处推导都会被使用。例如，考虑简单类型`Tuple`上的两个相似操作：
```cpp
template<typename... Types> class Tuple { };

template<typename... Types>
bool f1(Tuple<Types...>, Tuple<Types...>);

template<typename... Types1, typename... Types2>
bool f2(Tuple<Types1...>, Tuple<Types2...>);

void bar(Tuple<short, int, long> sv, Tuple<unsigned short, unsigned, unsigned long> uv)
{
  f1(sv, sv);	// OK: Types is deduced to {short int, long}
  f2(sv, sv);	// OK: Types1 is deduced to {short, int, long},
  				//     Types2 is deduced to {short, int, long}
  f1(sv, uv);	// ERROR: Types is deduced to {short, int, long} from the 1st arg, 
  				//        but to {unsigned short, unsigned, unsigned long} from the 2nd
  f2(sv, uv);	// OK: Types1 is deduced to {short, int, long},
  				//     Types2 is deduced to {unsigned short, unsigned, unsigned long}
}
```

`f1()`和`f2()`中，模板参数包都是将`Tuple`类型内嵌的包展开模式与调用实参所提供的`Tuple`类型进行比较，为一致的模板参数包推导出正确的值。函数`f1()`对两个函数参数使用相同的模板参数包`Types`，确保只有当两个函数调用实参有相同的`Tuple`特化体类型时，才能推导成功。而`f2()`则为每个函数参数各使用了一个参数包，因此两个调用参数可以不同——也就可以使用`Tuple`的两种特化体类型。

### 15.5.1 字面量操作符模板
字面量操作符模板的实参通过一种特殊的方式来确定。下面的例子进行了阐释：
```cpp
template<char...> int operator "" _B7();	// #1
...
int a = 121_B7;		// #2
```

这里，#2处的初始化器包含了一个用户定义的字面量（它会转换成对字面操作符模板的调用，使用的模板实参列表为`<'1','2','1'>`）。因此，字面量操作符的实现体可能如下：
```cpp
template <char... cs>
int operator"" _B7()
{
  std::array<char,sizeof...(cs)> chars{cs...};	// initialize array of passed chars
  for(char c : chars) {							// and use it (print it here)
    std::cout << "'" << c << "'";
  }
  std::cout << '\n';
  return ...;
}
```

它会为121.5_B7输出`'1' '2' '1' '.' '5'`。

请注意，仅在没有后缀的情况下仍然有效的数值字面量才支持此技术。例如：
```cpp
auto b = 01.3_B7;	// OK: deduces <'0','1','.','3'>
auto c = 0xFF00_B7;	// OK: deduces <'0','x','F','F','0','0'>
auto d = 0815_B7;	// ERROR: 8 is no valid octal literal 
auto e = hello_B7;	// ERROR: identifier hello_B7 is not defined
auto f = "hello"_B7;	// ERROR: literal operator _B7 does not match
```

参考P599节25.6对这一特性的应用：编译期计算整型字面量。

## 15.6 右值引用
C++11引入的右值引用促生了许多新技术，包括移动语义和完美转发。本节会描述右值引用与推导之间的交互。

### 15.6.1 引用折叠法则
开发者不允许直接声明“引用的引用”：
```cpp
int const& r = 42;
int const& & ref2ref = i;	// ERROR: reference to reference is invalid
```

然而，当通过模板参数替换、类型别名或是`decltype`结构构造类型时，“引用的引用”将被允许。例如：
```cpp
using RI = int&;
int i = 42;
RI r = i;
R const& rr = r;	// OK: rr has type int&
```

从诸如这种结构中确定类型的结果的规则就是众所周知的引用折叠法则。首先，任何应用于内部引用顶层的`const`或`volatile`限定符都会被舍弃（也就是说，只有内层引用的底层限定符才会被保留）。此后，这两种引用会根据表15.1推导出一个单一引用，这种推导方式可以总结为一句话：“如果某个引用是左值引用，那么结果也一定是左值引用，否则就是右值引用”。

<center>
	
| 内层引用 | 外层引用 | 结果引用 |
| - | - | - |
| & | & | & |
| & | && | & |
| && | & | & |
| && | && | && |
	
表15.1 引用折叠法则
</center>

另一个例子展示了这些规则的作用：
```cpp
using RCI = int const &;
RCI volatile&& r = 42;	// OK: r has type int const &;
using RRI = int&&;
RRI const&& rr = 42;	// OK: rr has type int&&
```

这里`volatile`被应用在`RCI`这一引用类型（`int const&`的别名）的顶层，因此会被丢弃掉。这一类型的顶层又放置了一个右值引用，但是由于底层类型是一个左值引用（左值引用在引用折叠规则中“更优先”），所以最终的类型保留为`int const&`（或者`RCI`类型、一个等价的别名）。类似地，`RRI`的顶层const会被丢弃，在右值引用类型上应用一个右值引用，最后的结果依然是一个右值引用类型（可以绑定到像42这样的右值上）。

### 15.6.2 转发引用
如同P91节6.1所介绍的那样，当函数参数是一个转发引用（函数模板参数中的右值引用）时，模板实参推导会呈现另一种表现形式。此时，模板实参推导不仅会考虑函数调用实参的类型，同时也会考虑该实参是左值还是右值。如果实参是一个左值，那么模板实参推导所确定的类型就是该实参类型的左值引用类型，引用折叠规则会确保所替换的参数可以成为一个左值引用。如果实参不是左值，那么模板参数所推导的类型就是实参类型，而替代的参数是该类型的右值引用。例如：
```cpp
template<typename T> void f(T&& p);	// p is a forwarding reference

void g()
{
  int i;
  int const j = 0;
  f(i);		// argument is an lvalue; deduces T to int& and
  			// parameter p has type int&
  f(j);		// argument is an lvalue; deduces T to int const& 
  			// parameter p has type int const&
  f(2);		// argument is an rvalue; deduces T to int
  			// parameter p has type int&&
}
```

在调用`f(i)`中，模板参数`T`被推导为`int&`，因为表达式`i`是一个类型为`int`的左值。`T`替换`int&`到参数类型`T&&`中需要引用折叠，这里我们使用规则`&`+`&&`->`&`来得出结论：参数类型为`int&`，如此就可以完美的接受`int`类型的左值。相对的，在调用`f(2)`中，实参`2`是一个右值，模板参数因此直接被推导为右值的类型（即`int`）。这里不需要进行引用折叠，其结果直接就是`int&&`（同样地，对实参来说这是一个合适的参数类型）。

当`T`被推导为一个引用类型时，对于模板的实例化来说有些有趣的效果。例如，使用类型`T`声明的局部变量，在用左值实例化后，会有一个引用类型，而此时它就需要一个初始化器：
```cpp
template<typename T> void f(T&&)	// p is a forwarding reference
{
  T x;	// for passed lvalues, x is a reference
  ...
}
```

这就意味着函数`f()`的定义需要很小心地使用类型`T`，或者函数模板本身根本不为左值参数生效。为了解决这一困境，`std::remove_reference`型别萃取常常被用来确保`x`不是一个引用：
```cpp
template<typename T> void f(T&&)	// p is a forwarding reference
{
  std::remove_reference_t<T> x;		// x is never a reference
  ...
}
```

### 15.6.3 完美转发
右值引用特殊的推导规则和引用折叠法则组合在一起使得编写一个接受任何实参的函数模板以及捕捉其显著的特性（其类型、以及它是一个左值还是右值）成为了可能。函数模板此后可以“转发”这一实参给另一个函数，诸如此例：
```cpp
class C {
  ...
};

void g(C&);
void g(C const&);
void g(C&&);

template<typename T>
void forwardToG(T&& x)
{
  g(static_cast<T&&>(x));	// forward x to g()
}

void foo()
{
  C v;
  C const c;
  forwardToG(v);	// eventually calls g(C&)
  forwardToG(c);	// eventually calls g(C const&)
  forwardToG(C());	// eventually calls g(C&&)
  forwardToG(std::move(v));	// eventually calls g(C&&)
}
```

上例所展示的技术被称为完美转发(perfect forwarding)，因为通过`forwardToG()`间接调用`g()`的效果与直接调用`g()`相同：没有额外的拷贝，选择的重载函数`g()`也一模一样。

`static_cast`的使用需要一些额外的解释。在每个`forwardToG()`的实例化体重，参数`x`要么是一个左值引用类型，要么是一个右值引用类型。而无论如何，表达式`x`本身一定是一个（其引用类型的）左值。`static_cast`会将`x`转换为其原始类型（不管左值还是右值）。类型`T&&`要么折叠成一个左值引用（如果原本的实参是一个左值，那么`T`就是一个左值引用），要么是一个右值引用（原本的实参就是一个右值），因此`static_cast`的结果就有了一致的类型，不论原本的实参是左值也好、右值也罢，如此，就实现了完美转发。

如P91节6.1所介绍的那样，C++标准库提供了一个函数模板`std::forward<>()`（在头文件`<utility>`中），它被用来取代`static_cast`进行完美转发。相比晦涩难懂的`static_cast`结构来说，使用这一模板对开发者来说更加表意，同时也防止了诸如少写了一个`&`所导致的错误。那么，上面的例子可以更为简明地写成这个样子：
```cpp
#include <utility>

template<typename T> void forwardToG(T&& x)
{
  g(std::forward<T>(x));	// forward x to g()
}
```

#### 可变模板的完美转发
完美转发与可变模板搭配在一起，可以让函数模板接受任意数量的函数调用实参并将它们逐一转发到另一个函数：
```cpp
template<typename... Ts> void forwardToG(Ts&&... xs)
{
  g(std::forward<Ts>(xs)...);	// forward all xs to g()
}
```

`forwardToG()`的实参会为参数包`Ts`分别被推导出合适的值（见P275节15.5），因此类型以及每个参数的左值性或右值性都会被捕获。包展开（见P201节12.4.1）在调用`g()`时会将每个实参都应用上述的完美转发技术进行转发。

尽管它拥有一个“完美转发”的名字，但实际上，从它不能捕获表达式所有感兴趣属性的意义上来说，完美转发实际上并不“完美”。例如，它无法区分左值是不是一个位域(bit-field)左值，也无法捕获表达式是否有特定的常量值。后者尤其在我们处理空指针常量时常常导致问题（它是一个整型类型、常量零值）。由于表达式常量值不会被完美转发所捕获，下例中的重载解析对直接调用`g()`和转发调用`g()`来说，表现上会有所区别：
```cpp
void g(int*);
void g(...);

template<typename T> void forwardToG(T&& x)
{
  g(std::forward<T>(x));	// forward x to g()
}

void foo()
{
  g(0);				// calls g(int*)
  forwardToG(0);	// eventually calls g(...)
}
```

这也是为什么使用`nullptr`(C++11所引入)取代空指针常量的另一个原因：
```cpp
g(nullptr);		// calls g(int*)
forwardToG(nullptr);	// eventually calls g(int*)
```

我们所有完美转发的例子都聚焦于传递的函数实参要如何保留其精准的类型以及它是一个左值或是右值。当转发函数调用的返回值给另一个函数时，也要面临同样的问题（类型和值的分类，对左值和右值的概括在附录B中进行了讨论）。C++11引入的`decltype`语法（在P298节15.10.2中描述），有一个有些冗长的惯用手法；
```cpp
template<typename... Ts>
auto forwardToG(Ts&&... xs) -> decltype(g(std::forward<Ts>(xs))
{
  return g(std::forward<Ts>(xs)...);	// forward all xs to g()
}
```

请注意，`return`语句的表达式被拷贝到了`decltype`类型里，因此返回表达式的准确类型会被计算出来。尾随返回类型被使用（即，函数名称前的`auto`占位符和指示返回类型的`->`），使得函数参数包`xs`也在`decltype`类型的作用域。该转发函数会“完美地”转发所有实参给`g()`，然后再“完美地”转发其返回值给调用者。

C++14引入了额外的特性来简化这一情景：
```cpp
template<typename... Ts>
decltype(auto) forwardToG(Ts&&... xs)
{
  return g(std::forward<Ts>(xs)...);	// forward all xs to g()
}
```

使用`decltype(auto)`做返回类型会指示编译器通过函数定义来推导返回类型。参见P296节15.10.1和P301节15.10.3。

### 15.6.4 推导惊奇之处
对完美转发来说，右值引用的特殊推导规则非常有用。然而，有时候它们可能会令人意外，这是因为函数模板通常会泛化函数签名中的类型，不会影响它所允许的参数是何种类型（左值或右值）。考虑下例：
```cpp
void int_lvalues(int&);		// accepts lvalues of type int
templte<typename T> void lvalues(T&);	// accepts lvalues of any type

void int_rvalues(int&&);	// accepts rvalues of type int
template<typename T> void anything(T&&);	// SURPRISE: accepts lvalues and
											// rvalues of any type
```

抽象出一个像`int_lvalues`那样的函数的开发者，可能会对函数模板`anything`可以接受左值而感到惊奇。幸运的是，只有当函数参数写成特定的模板参数`&&`的形式时（作为函数模板的一部分且命名的模板参数是由该函数模板所声明），才会应用这一推导行为。因此，下面这些例子的情形都不会应用推导规则：

```cpp
template<typename T>
class X
{
  public:
    X(X&&);		// X is not a template parameter
	X(T&&);		// this constructor is not a function template
	
	template<typename Other> X(X<U>&&);	// X<U> is not a template parameter
	template<typename U> X(U, T&&);		// T is a template parameter from 
										// an outer template
};
```

尽管模板推导规则有着这些令人惊奇的行为，在实践中，这种行为导致问题的情况并不经常出现。当出现问题时，你可以组合使用SFINAE（参考P129节8.4和P284节15.7）和诸如`std::enable_if`的型别萃取来约束模板只能接受右值：
```cpp
template<typename T>
typename std::enable_if<!std::is_lvalue_reference<T>::value>::type 
rvalues(T&&);	// accepts rvalue of any type
```

## 15.7 SFINAE(Substitution Failure Is Not An Error)
SFINAE(替换失败并非错误)原则在P129节8.4中介绍过，它是模板实参推导中在重载解析期间防止不相干的函数模板产生错误的关键人。

例如，考虑这样一对函数模板，它们从给定的容器或数组榨取起始的迭代器：
```cpp
template<typename T, unsigned N>
T* begin(T (&array)[N])
{
  return array;
}

template<typename Container>
typename Container::iterator begin(Container& c)
{
  return c.begin();
}

int main()
{
  std::vector<int> v;
  int a[10];
  
  ::begin(v);	// OK: only container begin() matches, because the first deduction fails
  ::begin(a);	// OK: only array begin() matches, because the second substitution fails
}
```

第一个`begin()`调用的实参是`std::vector<int>`，它试图为两个`begin()`函数模板做模板实参推导：
- 对数组`begin()`的模板实参推导失败了，因为`std::vector`不是一个数组，所以被忽略。
- 模板实参推导对容器`begin`成功了，`Container`被推导成`std::vector<int>`，因此函数模板可以被实例化，也可以被调用。

第二个`begin()`调用的实参是一个数组，也会部分失败：
- 对数组`begin()`推导成功，`T`被推导为`int`，`N`被推导为`10`。
- 对容器`begin()`来说，推导需要将`Container`替换为`int[10]`，这本身没有问题，但是如此产生的返回类型`Container::iterator`却是无效的（因为数组类型并没有嵌套的名为`iterator`的类型）。在其他上下文中，试图访问一个本不存在的嵌套类型会立即导致一个编译期错误。而在模板实参的替换中，SFINAE会将这种错误转换成推导失败，并且不再将这一函数模板纳入考虑。因此，第二个`begin()`候选会被忽略，第一个`begin()`函数模板的特化体会被调用。

### 15.7.1 即时上下文
SFINAE防止了那些试图形成的无效类型或表达式，包括因歧义或非法访问控制所产生的错误，它们在函数模板替换的即时上下文中出现。比起定义函数模板替换的即时上下文，定义不在该上下文中可能更为容易。具体来说，在函数模板替换过程中，为了进行推导，下面这些元素的实例化体都不在函数模板替换的即时上下文中：
- 类模板的定义（即，类模板本身以及其基类列表）
- 函数模板的定义（即，函数模板本身，对构造函数来说，是其构造初始化器）
- 变量模板初始化器
- 默认实参
- 默认成员初始化器
- 异常规范

任何由替换过程所触发的隐式的特殊成员函数的定义也不在替换的即时上下文中。除此之外，尽在即时上下文中。

因此，如果在替换函数模板声明的模板参数时需要类模板本身的实例化体（因为该类被引用了），则实例化过程产生的错误并不在函数模板替换的即时上下文中，因此它会产生一个真正的错误（即使另一个函数模板可以无错误地匹配上）。例如：
```cpp
template<typename T>
class Array {
  public:
    using iterator = T*;
};

template<typename T>
void f(Array<T>::iterator first, Array<T>::iterator last);

template<typename T>
void f(T*, T*);

int main()
{
  f<int&>(0, 0);	// ERROR: substituting int& for T in the first function template
  					// instantiates Array<int&>, which then fails
}
```

本例与前例最主要的差别在于失败发生的位置。前例中，失败发生在形成一个类型为`typename Container::iterator`之时，它在`begin()`函数模板替换的即时上下文中。而本例中，失败发生在`Array<int&>`的实例化体中，尽管它是由函数模板上下文所触发，但实际上是发生在类模板`Array`的上下文中。因此，SFINAE原则并不适用，编译器会产生一个错误。

这里有一个C++14的例子——基于推导返回类型（P296节15.10.1）——在函数模板定义的实例化时导致错误：
```cpp
template<typename T> auto f(T p) {
  return p->m;
}

int f(...);

template<typename T> auto g(T p) -> decltype(f(p));

int main()
{
  g(42);
}
```

调用`g(42)`会推导`T`为`int`。这使得`g()`声明的替换需要我们去确定`f(p)`的类型（`p`现在已知为类型`int`），然后再确定`f()`的返回类型。`f()`有两个候选者。非模板候选者是匹配的，但它不是一个良选，这是因为它匹配的是一个省略型参数。不幸的是，模板候选者有一个推导的返回类型，因而我们必须实例化它的定义来确定该返回类型。该实例化会因为`p->m`无效而失败（因为`p`是`int`），并且该错误发生在替换上下文之外（因为它在随后的函数定义实例化体中），这就导致本次失败会产生一个错误。为此，我们推荐在可以容易地显式化指定返回类型时，避免使用推导返回类型。

SFINAE设计之初，是旨在消除由函数模板重载所带来的因非意图匹配而产生的奇怪错误，正如容器`begin`这一例子。然而，探测无效表达式或类型的能力可以实现卓越的编译时技巧，以允许我们判断某个特定的语法是否是合法的。这些技巧将在P416节19.4中进行讨论。

在P424节19.4.4中，有一个特别的例子：让型别萃取SFINAE-friendly来避免及时上下文所产生的问题。

## 15.8 推导的限制