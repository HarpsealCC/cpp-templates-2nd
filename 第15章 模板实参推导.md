# 第15章 模板实参推导
如果为每个函数模板都显式地指定模板实参，那么很快代码就会显得又笨又重（比如：`concat<std::string, int>(s, 3)`）。幸运的是，C++编译器常常可以自动判断模板实参类型，这是通过一个十分高效的过程——模板实参推导——来完成的。

本章中我们将详述模板实参推导这一过程的细节。和C++其他的知识一样，大多数规则通常会产生一个直观的结果，模板实参推导也不例外。此外，对这一章的深刻理解可以使我们以后避免遇到出人意料的情景。

尽管模板实参推导是为了简化函数模板的调用而首先开发的，但是自那以后，它已扩展到适用于其他几种用途，包括从其初始值设定项(initializer)确定变量的类型。

## 15.1 推导过程
基本的推导过程会比较“函数调用的实参类型”与“函数模板对应位置的参数化类型”，然后针对要被推导的一到多个参数，分别尝试去推断一个正确的替换项。每个实参-参数对都会独立分析，并且如果最终得出的结论产生矛盾(differ)，那么推导过程就失败了。

考虑下面的例子：
```cpp
template<typename T>
T max(T a, T b)
{
  return b < a ? a : b;
}

auto g = max(1, 1.0);
```

这里第一个调用实参的类型是`int`，因此我们原生的`max()`模板的参数`T`会被姑且推导成`int`。然而，第二个调用实参是`double`类型，基于此，`T`会被推导为`double`：这就与前一个推导产生了矛盾。注意：我们称之为“推导过程失败”，而不是“程序非法”。毕竟，可能对于另一个名为`max`（函数模板可以像普通函数那样被重载；参考P15节1.5和第16章）的模板来说推导过程可能是成功的。

即使所有被推导的模板实参都可以一致地确定（即不产生矛盾），推导过程仍然可能会失败。这种情况发生于：在函数声明中，进行替换的模板实参可能会导致无效的结构。请看下例：

```cpp
template<typename T>
typename T::ElementT at(T a, int i)
{
  return a[i];
}

void f(int* p)
{
  int x = at(p, 7);
}
```

这里`T`被推导为`int*`(`T`出现的地方只有一种参数类型，因此显然不会有解析矛盾)。然而，将`T`替换为`int*`在C++中对于返回类型`T::ElementT`显然是非法的，因此推导就失败了。

我们仍然需要探索实参-参数匹配如何进行。我们会使用下面的概念来进行描述：匹配类型A（来自实参的类型）和参数化类型P（来自参数的声明）。如果被声明的参数是一个引用，那么P就是所引用的类型，A仍然是实参的类型。如果声明的参数不是引用，那么P就是声明的参数类型，而A类型的获取则会经过数组和函数类型到指针类型的退化，并且会忽略顶层const和volatile限定符。例如：

```cpp
template<typename T> void f(T);		// parameterized type P is T
template<typename T> void g(T&);	// parameterized type P is also T

double arr[20];
int const seven = 7;

f(arr);		// nonreference parameter: 	T is double*
g(arr);		// reference parameter:		T is double[20]
f(seven);	// nonreference parameter: 	T is int
g(seven);	// reference parameter:		T is int const
f(7);		// nonreference parameter:	T is int
g(7);		// reference parameter:		T is int => ERROR: can't pass 7 to int&
```

对调用`f(arr)`来说，`arr`数组类型会退化为类型`double*`，作为推导的`T`的类型。在`f(seven)`中`const`限定符被忽略了，因此T被推导为`int`。相反地，`g(x)`推导`T`为类型`double[20]`(没有发生退化)。与此类似地，`g(seven)`有一个类型为`int const`的左值实参，并且因为在匹配引用参数时，`const`和`volatile`限定符不会被去除，`T`会被推导为`int const`。然而，注意由于`g(7)`想要推导`T`为`int`（因为非类的右值表达式永远不会有`const`或`volatile`限定类型），这一调用会失败，因为实参`7`无法作为一个`int&`类型的参数被传递。

引用类型的参数不会退化这一事实，对于参数为字符串字面量的场合来说可能会令人惊讶。重新审视我们的使用引用类型的`max()`模板声明：
```cpp
template<typename T>
T const& max(T const& a, T const& b);
```

对于表达式`max("Apple", "Pie")`来说，`T`被推断为`char const*`看起来很合理。然而，实际上`Apple`的类型是`char const[6]`、`Pie`的类型是`char const[4]`。这里并不会进行数组到指针的退化（因为推导涉及了引用类型的参数），因此想要推导成功，`T`必须既得是`char[6]`又得是`char[4]`。显然，这绝无可能。可以参考P115节7.4中对于如何处理这一场景的一个探讨。

## 15.2 推导上下文
比`T`复杂得多的参数化类型也可以匹配一个给定的实参类型。这里有一些相当基础的例子：
```cpp
template<typename T>
void f1(T*);

template<typename E, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1 (T2::*)(T3*));

class S {
  public:
    void f(double*);
};

void g(int*** ppp)
{
  bool b[42];
  f1(ppp);		// deduces T to be int**
  f2(b);		// deduces E to be bool and N to be 42
  f3(&S::f);	// deduces T1 = void, T2 = S, and T3 = double
}
```

复杂的类型声明都是用比它更基本的结构（例如指针、引用、数组、函数声明；成员指针声明；模板ID等）来组成的，匹配过程从最顶层结构开始处理，一路递归其各种组成元素。可以说基于这一方法，大部分类型声明结构都可以进行匹配，而这些结构也被称为“推导上下文“。然而，有些结构不能作为推导上下文。例如：
- 受限的类型名称。例如，形如`Q<T>::X`的类型名称永远不会用来推导模板参数`T`。
- 除了非类型参数之外，模板参数还包含其他成分的非类型表达式。例如，形如`S<I+1>`的类型名称永远不会用于推导`I`。再比如，`T`也不会通过匹配形如`int(&)[sizeof(S<T>)]`类型的参数来推导。这些限制合乎常理，因为通常来说，推导并不是唯一的（甚至不一定是有限的），尽管有时候会很容易忽略这些受限的类型名称。此外，一个不能推导的上下文并不会自动地表明：所对应的程序有错误，或者甚至前面分析过的参数不能再次进行类型推导。为了阐释这一事实，考虑下面这个更为错综复杂的例子：
```cpp
template<int N>
class X {
  public:
    using I = int;
	void f(int) {}
};

template<int N>
void fppm(void (X<N>::*p)(typename X<N>::I));

int main()
{
  fppm(&X<33>::f);		// fine: N deduced to be 33
}
```

在函数模板`fppm()`中，子结构`X<N>::I`是一个不可推导的上下文。然而，具有成员指针类型（即`X<N>::*p`）的成员类型部分`X<N>`是一个可推导上下文。于是，可以根据这个可推导上下文获得参数`N`，然后把`N`放入不可推导的上下文`X<N>::I`，就能获得与实参`＆X<33>::f`相配的类型。因此基于这个实参-参数对的推导就是成功的。

相反，对于完全依赖推导上下文的参数类型来说，有可能会产生推导矛盾。例如，假设我们已恰当地声明过类模板`X`和`Y`：
```cpp
template<typename T>
void f(X<Y<T>, Y<T>>);

void g()
{
  f(X<Y<int>, Y<int>>());	// OK
  f(X<Y<int>, Y<char>>());	// ERROR: deduction fails
}
```

第二个调用的问题在于两个实参对于参数`T`的推导是不同的，而这显然是无效的（两种情景里，函数调用实参都是一个临时的对象，这一对象借由调用类模板`X`的默认构造器而获得）。

## 15.3 特殊的推导情况
存在一些特殊的情况：用于推导的实参-参数对（A, P）并不是分别来自于函数调用的实参和函数模板的参数。第一种情况出现在取函数模板地址的时候。此时，P是函数模板声明的参数化类型（即下面`f`的类型），而A是被赋值（或者初始化）的指针（即下面的`pf`）所代表的函数类型。例如：
```cpp
template<typename T>
void f(T, T);

void (*pf)(char,char) = &f;
```

在本例中，P是`void(T, T)`，而A是`void(char, char)`。推导随着`T`被`char`替换而成功，而`pf`用特化体`f<char>`的地址进行初始化。

类似地，函数类型在一些其他特殊情况下也被P和A所使用：
- 确定重载函数模板之间的偏序
- 将某个显式特化体与某个函数模板匹配
- 将某个显式实例化体与某个模板匹配
- 将某个友元函数模板特化体与某个模板匹配
- 将占位(replacement)`operator delete`或是`operator delete[]`与对应的占位`operator new`或`operator new[]`模板匹配。

这些话题中的部分内容，以及类模板偏特化中模板实参推导的使用，会在第16章中进行展开。

另一种特殊情况和转型运算符模板一起出现。例如：
```cpp
class S {
  public:
    template<typename T> operator T&();
};
```

在本例中，实参-参数对(P, A)的获取涉及到我们试图进行转型的实参和转换运算符的返回类型。下面的代码清楚地说明了这种情况：
```cpp
void f(int (&)[20]);

void g(S s)
{
  f(s);
}
```

这里，我们试图把`S`转型为`int(&)[20]`，因此，类型A为`int[20]`，而类型P为`T`。当`T`被`int[20]`替换时，推导就是成功的。

最后，对于`auto`占位类型来说，也需要一些特殊的对待。这会在P303节15.10.4中进行讨论。

## 15.4 初始化列表(initializer list)
当函数调用的实参是一个初始化列表时，该实参是没有一个特定的类型的，因此通常来说，对于给定实参-参数对(A, P)，不会进行任何推导，因为这里并不存在A。例如：
```cpp
#include <initializer_list>

template<typename T> void f(T p);

int main() {
  f({1, 2, 3});		// ERROR: cannot deduce T from a braced list
}
```

然而，如果参数类型P（在移除引用、顶层const和volatile限定符后）与`std::initializer_list<P'>`等价（对某些类型`P'`来说有一个可推导的模式(deducible pattern))，推导过程会将初始化列表的每个元素类型与`P'`进行比较，只有在所有的元素类型都有相同的类型时，推导才是成功的。
*deduce/initlist.cpp*
```cpp
#include <initializer_list>

template<typename T> void f(std::initializer_list<T>);

int main()
{
	f({2,3,5,7,9});						// OK: T is deduced to int
	f({'a', 'e', 'i', 'o', 'u', 42});	// ERROR: T deduced to both char and int
}
```

类似地，如果参数类型`P`是一个`P'`类型数组的引用（有一个可推导的模式），推导过程也会将初始化列表的每个元素的类型与`P'`进行比较，当且仅当所有元素都有相同的类型时，推导成功。此外，如果（数组）边界有一个可推导模式（即，仅命名一个非类型模板参数），那么该边界会被推导为初始化列表中元素的数量。

## 15.5 参数包
