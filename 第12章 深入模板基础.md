# 第12章 深入模板基础

在本章中，我们将深入探讨本书第一部分中介绍的一些基础知识：模板的声明，模板参数(template paramenters)的限制(restrictions)，模板实参(template arguments)的限制(constraints)等等。
## 12.1 参数化声明
C++目前支持4种基础模板：类模板、函数模板、变量模板以及别名模板。每一种模板都既可以出现在命名空间作用域，也可以出现在类作用域。在类作用域中，它们作为嵌套的类模板、成员函数模板、静态数据成员模板以及成员别名模板。此类模板的声明与普通类、函数、变量以及类型别名（或者是它们的类成员副本）非常相似，只不过需要一个形如`template<parameters here`的子句来做前置指引。

注意到C++17引入了另一种带有这样的参数化子句的结构：推导指引(deduction guides)(参考P42节2.9以及P314节15.12.1)。本书中它们不被称为模板(因为它们没有被实例化)，但是这一语法的选择会让人联想到函数模板。

在下一节中，我们将重返实际模板参数声明。首先，一些示例用以说明四种类型的模板。它们可以像这样在命名空间作用域（全局或是某个命名空间内）中出现：

*details/definitions1.hpp*

```cpp
template<typename T> // a namespace scope class template
class Data {
  public:
    static constexpr bool copyable = true;
    …
};

template<typename T> // a namespace scope function template
void log (T x) {
  …
}

template<typename T> // a namespace scope variable template (since C++14)
T zero = 0;

template<typename T> // a namespace scope variable template (since C++14)
bool dataCopyable = Data<T>::copyable;

template<typename T> // a namespace scope alias template
using DataList = Data<T*>;

```

注意到示例中，静态数据成员`Data<T>::copyable`并不是一个变量模板，尽管它是通过类模板`Data`参数所间接参数化的。然而，变量模板可以出现在类作用域中(下一个例子会展示)，彼时它将作为一个静态数据成员模板。

下面展示了定义在所属类中的4种模板，它们都是类的成员：

*details/definitions2.hpp*
```cpp
class Collection {
  public:
  	template<typename T> 	// an in-class member class template definition
	class Node {
	  ...
	};
	
	template<typename T>	// an in-class (and therefore implicitly inline)
	T* alloc() {			// member function template definition
	  ...
	}
	
	template<typename T>	// a member variable template (since c++14)
	static T zero = 0;
	
	template<typename T>	// a member alias template
	using NodePtr = Node<T>*;
};
```

注意到在C++17中，变量（包括静态数据成员）以及变量模板都可以是内联的，内联意味着它们的定义可以跨越多个编译单元重复。对于总能定义在多个编译单元中的变量模板来说，这是多余的。但类内定义的静态数据成员不会像成员函数一样内联，因此就要指定inline关键字。

最后，下面的代码演示了如何在类外定义别名模板以外的成员模板：

*details/definitions3.hpp*
```cpp
template<typename T>	// a namespace scope class template
class List {
  public:
    List() = default;	// because a template constructor is defined
	
	template<typename U>	// another member class template,
	class Handle;			// without its defination
	
	template<typename U>	// a member function template
	List (List<U> const&);	// (constructor)
	
	template<typename U>	// a member variable template (since C++14)
	static U zero;
};

template<typename T>	// out-of-class member class template definition
template<typename U>
class List<T>::Handle {
  ...
};

template<typename T>	// out-of-class member function template definition
template<typenaame T2>
List<T>::List(List<T2> const& b)
{
  ...
}

template<typename T>	// out-of-class static data member template definition
template<typename U>
U List<T>::zero = 0;
```

定义在类外的成员模板需要多个`template<... >`参数化子句：每个封闭的类模板一个，成员模板本身也需要一个。子句从类模板最外层开始逐行展示。

同时也注意到构造器模板（一种特殊的成员函数模板）会禁用掉隐式声明的默认构造器（因为只有在没有其他构造器被声明时，默认构造器才会被声明）。增加一个默认的声明：

```cpp
List() = default;
```

这确保了`List<T>`的实例可以通过隐式声明的默认构造器构造出来。

**联合体模板**
联合体模板(union templates)也是可行的（它们被视为一种类模板）：

```cpp
template<typename T>
union AllocChunk {
  T object;
  unsigned char bytes[sizeof(T)];
};
```

**默认调用参数**
函数模板可以有默认参数，就如同普通的函数一样：

```cpp
template<typename T>
void report_top(Stack<T> const&, int number = 10);

template<typename T>
void fill(Array<T>&, T const& = T{});	// T{} is zero for built-in types
```

第二个声明展示了默认调用参数可以依赖于模板参数。它也可以被定义成如下形式（在C++11之前唯一可行的方式，可以参考P68节5.2）：

```cpp
template<typename T>
void fill(Array<T>&, T const& = T());	// T() is zero for built-in types
```

当`fill()`函数被调用时，如果传入了第二个参数，那么默认参数不会实例化。这保证了如果默认调用参数对特定`T`无法实例化的情景下不会发生错误。例如：

```cpp
class Value {
  public:
    explicit Value(int);	// no default constructor
};

void init(Array<Value>& array)
{
  Value zero(0);
  
  fill(array, zero);	// OK: default constructor not used
  fill(array);			// ERROR: undefined default constructor for Value is used
}
```

**类模板的非模板成员**
除了类内定义的4种基础模板以外，你还可以定义普通的类成员作为类的一部分。它们有时（错误地）也称为成员模板(member templates)。尽管它们可以被参数化，但这种定义并非头等模板。它们的参数完全由其成员的模板决定。例如：

>不太会翻译：Although they can be parameterized, such definitions aren’t quite first-class templates. 

```cpp
template<int I>
class CupBoard
{
  class Shelf;		// ordinary class in class template
  void open();		// ordinary function in class template
  enum Wood : unsigned char;		// ordinary enumeration type in class template
  static double totalWeight;		// ordinary static data member in class template
};
```

相应的定义仅仅只是为所属的类模板指定了参数化子句，但是却并没有为成员本身指定，因为其并非是一个模板（没有参数化子句与最后一个::之后出现的名称相关联）。

```cpp
template<int I>		// definition of ordinary class in class template
class CupBoard<I>::Shelf {
  ...
};

template<int I>		// definition of ordinary function in class template
void CupBoard<I>::open()
{
  ...
}

template<int I>		// definition of ordinary enumeration type class in class template
enum CupBoard<I>::Wood {
  Maple, Cherry, Oak
};

template<int I>		// definition of ordinary static member in class template
double CupBoard<I>::totalWeight = 0.0;

```

C++17之后，静态成员`totalWeight`可以在类模板内部使用`inline`关键字初始化。

```cpp
template<int I>
class CupBoard {
  ...
  inline static double totalWeight = 0.0;
};
```

尽管这种参数化定义通常被称作模板，但这里的“模板”一词相当不适用于此。对于这种情况一个被经常推荐的词是"temploid"。C++17之后，C++标准定义了模板化实体(a templated entity)的概念，它包括templates和temploids，并递归的包含模板化实体中创建或定义的任何实体（这包括，例如，一个类模板内定义的友元函数（参考P30节2.4）或是模板中出现的一个lambda表达式闭包）。不管是temploid还是templated entity目前都没有产生吸引力，但是在未来更精准的沟通C++模板时它们可能会很有用。

### 12.1.1 虚成员函数
成员函数模板不能被声明为virtual。施加这一限制是因为虚函数调用机制的通用实现会使用一个固定大小的虚表，其中存储了每一个虚函数条目（译者注：虚函数指针）。然而，成员函数模板直到整个程序被编译之前，实例化的个数都无法固定。因此，成员函数模板支持virtual需要C++编译器和链接器支持一种全新的机制。

相反的，类模板的普通成员函数可以是virtual，因为它们的数量是固定的。

```cpp
template<typename T>
class Dynamic {
  public:
    virtual ~Dynamic();	// OK: one destructor per instance of Dynamic<T>
	
	template<typename T2>
	virtual void copy(T2 const&);	// ERROR: unknown number of instances of copy()
									// given an instance of Dynamic<T>
};
```

### 12.1.2 模板的链接
每个模板都必须有一个名字，并且该名字必须是所属作用域内独一无二的，除却函数模板重载的情景（参考第16章）。特别要注意，与类类型不同，类模板无法与不同类型的实体共享名称：

```cpp
int C;
...
class C;	// OK: class names and nonclass names are in a different "space"

int X;
...
template<typename T>
class X;	// ERROR: conflict with variable X

struct S;
...
template<typename T>
class S;	// ERROR: conflict with struct S
```

模板名称具有链接，但是他们无法拥有C链接。非标准链接可能具有某个依赖于实现体的意义（然而我们并不知道某个实现体支持模板的非标准链接与否）：

```cpp
extern "C++" template<typename T>
void normal();		// this is the default: the linkage specification could be left out

extern "C" template<typename T>
void invalid();		// ERROR: templates cannot have C linkage

extern "Java" template<typename T>
void javaLink();	// nonstandard, but maybe some compiler will someday 
					// support linkage compatible with Java generics
```

模板通常有外部链接。唯一的一些例外是命名空间作用域中具有静态限定符的函数模板、匿名空间的直接或间接的成员的模板（它们拥有内部链接）以及匿名类的成员模板（它们没有链接）。

举个例子：

```cpp
template<typename T> 	// refers to the same entity as a declaration of the 
void external()			// same name (and scope) in another file

template<typename T>	// unrelated to a template with the same name in
static void internal();	// another file

template<typename T>	// redeclaration of the previous declaration
static void internal();

namespace {
  template<typename>	// also unrelated to a template with the same name
  void otherInternal();	// in another file, even one that similarly appears
}						// in an unnamed namespace

namespace {
  template<typename>	// redeclaration of the previous template declaration
  void otherInternal();
}

struct {
  template<typename T> void f(T) {} // no linkage: cannot be redeclared
} x;
```

注意到最后面的成员模板没有链接，它必须在匿名类定义处定义，因为想要在类外部定义是不可能的。

当前模板无法在函数作用域或局部类作用域中声明，但是泛化的lambda可以（参考P309节15.10.6），它有一个关联的闭包类型，其中包含了成员函数模板，其可以在局部作用域中出现，这实际上意味着一种局部成员函数模板。

模板实例的链接就是模板的链接。例如，函数`internal<void>()`从上面声明的模板`internal`实例化出来，它会拥有一个内部链接。而对于变量模板来说，这会产生一个有趣的后果。实际上，考虑下例：

```cpp
template<typename T> T zero = T{};
```

`zero`所有实例化的实例都拥有一个外部链接，即使哪怕形如`zero<int const>`也是如此。这可能对既定的拥有一个内部链接的`int const zero_int = int{};`来说是违反直觉的，毕竟它使用了一个`const`类型来做修饰。同样的，模板`template<typename T> int const max_volume = 11;`实例化的所有实例也都拥有外部链接，尽管哪些实例同样也包含类型`int const`。

### 12.1.3 主模板
模板的一般性声明声明了主模板(primary templates)。如此声明的模板在模板名后无需书写尖括号模板参数子句。

```cpp
template<typename T> class Box;		// OK: primary template
template<typename T> class Box<T>;	// ERROR: does not specialize

template<typename T> void translate(T);	// OK: primary template
template<typenaem T> void translate<T>(T);	// ERROR: not allowed for functions

template<typename T> constexpr T zero = T{};	// OK: primary template
template<typename T> constexpr T zero<T> = T{};	// ERROR: does not specialize

```

非主模板会在声明类或变量模板的偏特化时出现。这些将在第16章讨论。函数模板必须是主模板（参考P356节17.3，这里讨论了未来语言变化的某种潜在可能）。

## 12.2 模板参数(Template Parameters)
有三种基本类型的模板参数：
1. 类型参数（目前最常用的）
2. 非类型模板参数
3. 模板模板参数

这些基本类型的模板参数中的任何一种都可以用作模板参数包的基础（参考P188节12.2.4）。

模板参数在模板声明的参数化引导子句中声明，该声明无需命名：

```cpp
template<typename, int>
class X;		// X<> is parameterized by a type and an integer
```

当然，参数是否需要名称取决于模板后面的语句。还要注意，模板参数名可以在后续参数声明中引用（但前置则不行）：

```cpp
template<typename T,			//the first parameter is used 
		T root,					// in the declaration of the second one and
		template<T> class Buf>	// in the declaration of the third one
class Structure;
```

### 12.2.1 类型参数
类型参数由关键字`typename`或`class`所引导：二者是完全等价的。关键字后必须有一个简单的标识符，并且该标识符后必须带有逗号，以表示下一个参数声明的开始，闭合的尖括号`>`用以指示参数化子句的结束，`=`用以指示一个默认模板参数的起始位置。

在模板声明内，类型参数的行为与类型别名(type alias)非常相似（参考P38节2.8）。例如，当`T`是模板参数时，即使`T`是被某种类(class)类型取代，也不能使用形如`class T`的详尽名称：

```cpp
template<typename Allocator>
class List {
  class Allocator* allocptr;	// ERROR: use "Allocator* allocptr"
  friend class Allocator;		// ERROR: use "friend Allocator"
  ...
};
```

### 12.2.2 非类型参数
非类型模板参数表示一个可以再编译期或链接期确定的常量值。这样的参数类型（换句话说，它所代表的值类型）必须是以下之一：
- 整型或枚举型
- 指针类型
- 成员指针类型
- 左值引用类型（既可以是对象引用，也可以是函数引用）
- `std::nullptr_t`
- 包含`auto`或`decltype(auto)`的类型（C++17后支持；可参考P296节15.10.1）

其他类型当前都不支持（尽管浮点数在未来会被支持；可参考P356节17.2）。

也许令人惊讶的是，在某些情况下，非类型模板参数的声明也可以以关键字`typename`开头：

```cpp
template<typename T, 			// a type parameter
		typename T::Allocator* Allocator>	// a nontype parameter
class List;

template<class X*>		// a nontype parameter of pointer type
class Y;
```

这两种情形很容易辨别，因为第一种的后面跟随了一个简单的标识符，然后是一小段标记（'='用以表示默认参数，','用以指示后面的另一个模板参数，'>'用以闭合模板参数列表）。P67节5.1和P229节13.3.2对第一个非类型模板参数的关键字`typename`做出了解释。

函数和数组类型可以被指定，但是它们会通过退化(decay)隐式地调整为相应的指针类型：

```cpp
template<int buf[5]> class Lexer;		// buf is really an int*
template<int* buf> class Lexer;			// OK: this is a redeclaration

template<int fun()> struct FuncWrap;	// fun really has pointer to
										// function type
template<int (*)()> struct FuncWrap;	// OK: this is a redeclaration
```

非类型模板参数的声明与变量声明非常相似，但是它们不可以有非类型指示符，比如`static`、`mutable`等等。它们可以有`const`和`volatile`限定符，但是如果这种限定符出现在参数类型的最顶层，就会被忽略（译者注：换句话说，对左值引用或指针来说支持底层const）：

```cpp
template<int const length> class Buffer;	// const is useless here
template<int length> class Buffer;			// same as previous declaration
```

最后，在表达式中使用时，非引用类型的非类型参数始终都是`prvalues`（译者注：pure right values，即纯右值）。它们的地址无法被取缔，也无法被赋值。而另一方面，左值引用类型的非类型参数是可以像左值一样使用的：

```cpp
template<int& Counter>
struct LocalIncrement {
  LocalIncrement() { Counter = Counter + 1; }	// OK: reference to an integer
  ~LocalIncrement() { Counter = Counter - 1; }
};
```

右值引用是不被允许的。

### 12.2.3 模板模板参数
模板模板参数是类或别名模板的占位符。它们的声明与类模板很像，但是不能使用关键字`struct`或`union`：

```cpp
template<template<typename X> class C>		// OK
void f(C<int>* p);

template<template<typename X> struct C>		// ERROR: struct not valid here
void f(C<int>* p);

template<template<typename X> union C>		// ERROR: union not valid here
void f(C<int>* p);
```

C++17允许用`typename`替代`class`，这种变化是由以下事实引起的：模板模板参数不仅可以由类模板替代，而且可以由别名模板（可以实例化为任意类型）替代。因此，在C++17中，我们的上例可以改写成如下形式：

```cpp
template<template<typename X> typename C>		// OK since C++17
void f(C<int>* p);
```

在其声明的作用域内，模板模板参数用起来就像另一个类模板或是别名模板一样。

模板模板参数的参数可以有默认模板参数。在使用模板模板参数而未指定相应的参数时，这些默认参数会生效：

```cpp
template<template<typename T, 
				  typename A = MyAllocator> class Container>
				  
class Adaptation {
  Container<int> storage;	// implicitly equivalent to Container<int,MyAllocator>
  ...
};
```

`T`和`A`都是模板模板参数`Container`的模板参数名称。这些名称仅在该模板模板参数的其他参数的声明中使用。以下设计模板说明了此概念：

```cpp
template<template<typename T, T*> class Buf>	// OK
class Lexer {
  static T* storage;	// ERROR: a template template parameter cannot be used here
  ...
};
```

但是，通常在其他模板参数的声明中不需要模板模板参数的模板参数名称，因此常常根本不命名。例如，我们早期的`Adaptation`模板可以按如下声明：

```cpp
template<template<typename,
				  typename = MyAllocator> class Container>
class Adaptation {
  Container<int> storage;	// implicitly equivalent to Container<int,MyAllocator>
  ...
};
```

### 12.2.4 模板参数包
从C ++ 11开始，可以通过在模板参数名称之前引入省略号（…）来将任何类型的模板参数转换为模板参数包，如果模板参数是匿名的话，就是模板参数名称本该出现的位置：

```cpp
template<typename... Types>		// declares a template parameter pack named Types
class Tuple;
```

模板参数包的行为与其基础模板参数类似，但有一个关键的区别：普通的模板参数严格匹配某一个模板实参(template argument)，而模板参数包可以匹配任意数量的模板实参。这意味着上面声明的`Tuple`类模板可以接受任意数量任意类型（很可能彼此不一样）的模板实参：

```cpp
using IntTuple = Tuple<int>;			// OK: one template argument
using IntCharTuple = Tuple<int, char>;	// OK: two template arguments
using IntTriple = Tuple<int, int, int>;	// OK: three template arguments
using EmptyTuple = Tuple<>;				// OK: zero templates arguments
```

同样，非类型和模板模板参数的模板参数包可以分别接受任意数量的非类型或模板模板实参，分别为：

```cpp
template<typename T, unsigned... Dimensions>
class MultiArray;		// OK: declares a nontype template parameter pack

using TransformMatrix = MultiArray<double, 3, 3>;	// OK: 3x3 matrix

template<typename T, template<typename,typename>... Containers>
void testContainers();	// OK: declares a template template parameter pack
```

`MultiArray`示例需要全部的非类型模板实参均为相同的`unsigned`类型。C++17引入了非类型模板实参的推导，这将允许我们解除这一限制而做一些扩展——参考P298节15.10.1了解更多细节。

主模板中的类模板、变量模板和别名模板至多只可以有一个模板参数包，且模板参数包必须作为最后一个模板参数。函数模板则少些限制：允许多个模板参数包，只要模板参数包后面的每个模板参数都具有默认值（请参阅下一节）或可以推导（参考第15章）：

```cpp
template<typename... Types, typename Last>
class LastType;		// ERROR: template parameter pack is not the last template parameter

template<typename... TestTypes, typename T>
void runTests(T value);		// OK: template parameter pack is followed
							// by a deducible template parameter
template<unsigned...> struct Tensor;
template<unsigned... Dims1, unsigned... Dims2>
auto compose(Tensor<Dims1...>, Tensor<Dims2...>);	// OK: the tensor dimensions can be deduced
```

最后一个例子使用了返回类型推导——C++14的特性。可以参考P296节15.10.1。

类的偏特化声明以及变量模板（参考第16章）可以有多个参数包，这与主模板不同。这是因为偏特化是通过与函数模板几乎相同的推导过程所选择的。

```cpp
template<typename...> Typelist;
template<typename X, typename Y> struct Zip;
template<typename... Xs, typename... Ys>
struct Zip<Typelist<Xs...>, Typelist<Ys...>>;
			// OK: partial specialization uses deduction to determine
			// the Xs and Ys substitutions
```

也许不足为奇的是，类型参数包不能在其自己的参数子句中进行扩展。例如：

```cpp
template<typename... Ts, Ts... vals> struct StaticValues {};
	// ERROR: Ts cannot be expanded in its own parameter  list
```

然而，嵌套模板可以创造相似的有效情景：

```cpp
template<typename... Ts> struct ArgList {
  template<Ts... vals> struct Vals {};
};
ArgList<int, char, char>::Vals<3, 'x', 'y'> tada;
```

包含模板参数包的模板被称为可变参数模板(variadic template)，因为它接受可变数量的模板参数。第4章和P200节12.4介绍了可变参数模板的使用。

### 12.2.5 默认模板实参
非模板参数包的任何类别的模板参数都可以配置默认参数，尽管它必须与相应的参数匹配（例如，类型参数不能有一个非类型默认实参）。默认实参不能依赖于其自身的参数，因为参数的名称直到默认实参之后才在作用域内生效。然而，他可以依赖前面的参数：

```cpp
template<typename T, typename Allocator = allocator<T>>
class List;
```

当且仅当还为后续参数提供了默认参数时，类模板、变量模板或别名模板的模板参数才可以具有默认模板实参。（对默认函数调用参数来说有着相似的限制条件。）通常在同一模板声明中提供后续所有的默认值，但也可以在该模板的先前声明中声明它们。下面的例子可以清楚地做出解释：

```cpp
template<typename T1, typename T2, typename T3,
		 typename T4 = char, typename T5 = char>
class Quintuple;	// OK

template<typename T1, typename T2, typename T3 = char,
		 typename T4, typename T5>
class Quintuple;	// OK: T4 and T5 already have defaults

template<typename T1 = char, typename T2, typename T3, 
		 typename T4, typename T5>
class Quintuple;	// ERROR: T1 cannot have a default argument
					// because T2 doesn't have a default
```

函数模板的模板参数的默认模板实参不需要后续的模板参数必须有一个默认模板实参：

```cpp
template<typename R = void, typename T>
R* addressof(T& value);	// OK: if not explicitly specified, R will be void
```

默认模板实参不允许重复声明：

```cpp
template<typename T = void>
class Value;

template<typename T = void>
class Value;	// ERROR: repeated default argument
```

许多上下文不允许使用默认模板实参：
- 偏特化：
```cpp
template<typename T>
class C;
...
template<typename T = int>
class C<T*>;	// ERROR
```
- 参数包：
```cpp
template<typename... Ts = int> struct X;	// ERROR
```
- 类模板成员类外定义：
```cpp
template<typename T> 
struct x
{
	T f();
};

template<typename T = int> // ERROR
T X<T>::f() {		
  ...
}
```
- 友元类模板声明：
```cpp
struct S {
  template<typename = void> friend struct F;
};
```
- 友元类模板声明，除非它是一个定义并且它在编译单元的其他任何地方都没有声明：
```cpp
struct S{
  template<typename = void> friend void f();	// ERROR: not a definition
  template<typename = void> friend void g() {	// OK so far
  }
};

template<typename> void g();	// ERROR: g() was given a default template argument
								// when defined; no other declaration may exist here
```

## 12.3 模板实参(Template Arguments)
实例化模板时，模板实参会取代模板参数。模板实参可以被各种不同类型的机制所判定：
- 显式模板实参：模板名称后可以跟随在尖括号内显式指定的模板实参。这一结果的名称被叫做模板ID（template-id）。
- 注入式类名：在具有模板参数`P1，P2 ...`的类模板`X`的作用域内，该模板（`X`）的名称可以等价于模板ID `X<P1, P2, ...>`。可以参考P221节13.2.3了解更多细节。
- 默认模板实参：如果默认模板实参可用，则可以在模板实例时省略显式的模板实参。然而，对于类或别名模板来说，即使模板参数有默认值，尖括号也不能省略（其内可以为空）。
- 实参推导：没有被显式指定的函数模板参数会通过函数调用的实参类型来进行推导。在第15章对细节进行了描述。在一些其他情景中也会完成推导。如果所有的模板实参都可以被推导，那么函数模板的名称后就无需书写尖括号子句。C++17还引入了从变量声明或函数符号类型转换的初始化器中推导类模板实参的能力。可以参考P313节15.12中对此的一个探讨。

### 12.3.1 函数模板实参
函数模板的模板实参可以被显式地指定，它会从模板被使用的方式来做推导，或是由默认的模板实参来提供。例如：

*details/max.cpp*
```cpp
template<typename T>
T max(T a, T b)
{
  return b < a ? a : b;
}

int main()
{
  ::max<double>(1.0, -3.0);	// explicitly specify template argument
  ::max<1.0, -3.0);			// template argument is implicitly deduce to be double
  ::max<int>(1.0, 3.0);		// the explicit <int> inhibits the deduction;
  							// hence the result has type int
}
```

某些模板实参永远不会被推导，这可能是因为它们所对应的模板参数并没有在函数参数类型中出现或是一些其他原因（参考P271节15.2）。相应的参数通常放置在模板参数列表的开头，因此可以显式地指定它们，同时也允许推导其他参数。例如：

*details/implicit.cpp*
```cpp
template<typename DstT, typename SrcT>
DstT implicit_cast (SrcT const& x) 		// SrcT can be deduced, but DstT cannot
{
  return x;
}

int main()
{
  double value = implicit_cast<double>(-1);
}
```

如果我们翻转示例中模板参数的顺序（换句话说，写成`template<typename SrcT, typename DstT>`），`implicit_cast`的调用就必须同时显式地指定两个参数。

此外，这样的参数不能有效地放在模板参数包之后或在偏特化中出现，因为无法明确地指定或推导它们。

```cpp
template<typename... Ts, int N>
void f(double (&)[N+1], Ts... ps);	// useless declaration because N 
									// cannot be specified or deduced
```

由于函数模板可以重载，为函数模板显式地指定所有的实参可能也无法充分指定某一个特定函数：在某些场景中，它选中了一个函数集。下面的例子阐述了这一现象：

```cpp
template<typename Func, typename T>
void apply(Func funcPtr, T x)
{
  funcPtr(x);
}

template<typename T> void single(T);

template<typename T> void multi(T);
template<typename T> void multi(T*);

int main()
{
  apply(&single<int>, 3);	// OK
  apply(&multi<int>, 7);	// ERROR: no single multi<int>
}
```

本例中，第一个`apply()`调用可以成功是因为表达式`&single<int>`没有歧义。如此，模板实参值`Func`就可以被轻易的推断。在第二个调用中，`&multi<int>`可能是2种不同的类型，因此`Func`无法被推导。

更进一步，在函数模板中替换模板实参可能会导致尝试构造无效的C ++类型或表达式。考虑下面的重载函数模板（`RT1`和`RT2`没有指定类型）：

```cpp
template<typename T> RT1 test(typename T::X const*);
template<typename T> RT2 test(...);
```

表达式`test<int>`对于上述两种函数模板的前者来说都是没有意义的，因为类型`int`并没有成员类型`X`。然而，后者没有这样的问题。因此，表达式`&test<int>`标志了一个特定函数的地址。将`int`替换第一个函数模板失败的事实并不会使表达式无效。这一SFINAE	(substitution failure is not an error)原则对函数模板的重载来说是非常关键的一部分，我们会在P129节8.4和P284节节15.7中讨论。

### 12.3.2 类型实参
