# 第12章 深入模板基础
在本章中，我们将深入探讨本书第一部分中介绍的一些基础知识：模板的声明，模板参数(template paramenters)的限制(restrictions)，模板实参(template arguments)的限制(constraints)等等。
## 12.1 参数化声明
C++目前支持4种基础模板：类模板、函数模板、变量模板以及别名模板。每一种模板都既可以出现在命名空间作用域，也可以出现在类作用域。在类作用域中，它们作为嵌套的类模板、成员函数模板、静态数据成员模板以及成员别名模板。此类模板的声明与普通类、函数、变量以及类型别名（或者是它们的类成员副本）非常相似，只不过需要一个形如`template<parameters here`的子句来做前置指引。

注意到C++17引入了另一种带有这样的参数化子句的结构：推导指引(deduction guides)(参考P42节2.9以及P314节15.12.1)。本书中它们不被称为模板(因为它们没有被实例化)，但是这一语法的选择会让人联想到函数模板。

在下一节中，我们将重返实际模板参数声明。首先，一些示例用以说明四种类型的模板。它们可以像这样在命名空间作用域（全局或是某个命名空间内）中出现：

*details/definitions1.hpp*

```cpp
template<typename T> // a namespace scope class template
class Data {
  public:
    static constexpr bool copyable = true;
    …
};

template<typename T> // a namespace scope function template
void log (T x) {
  …
}

template<typename T> // a namespace scope variable template (since C++14)
T zero = 0;

template<typename T> // a namespace scope variable template (since C++14)
bool dataCopyable = Data<T>::copyable;

template<typename T> // a namespace scope alias template
using DataList = Data<T*>;

```

注意到示例中，静态数据成员`Data<T>::copyable`并不是一个变量模板，尽管它是通过类模板`Data`参数所间接参数化的。然而，变量模板可以出现在类作用域中(下一个例子会展示)，彼时它将作为一个静态数据成员模板。

下面展示了定义在所属类中的4种模板，它们都是类的成员：

*details/definitions2.hpp*
```cpp
class Collection {
  public:
  	template<typename T> 	// an in-class member class template definition
	class Node {
	  ...
	};
	
	template<typename T>	// an in-class (and therefore implicitly inline)
	T* alloc() {			// member function template definition
	  ...
	}
	
	template<typename T>	// a member variable template (since c++14)
	static T zero = 0;
	
	template<typename T>	// a member alias template
	using NodePtr = Node<T>*;
};
```

注意到在C++17中，变量（包括静态数据成员）以及变量模板都可以是内联的，内联意味着它们的定义可以跨越多个编译单元重复。对于总能定义在多个编译单元中的变量模板来说，这是多余的。但类内定义的静态数据成员不会像成员函数一样内联，因此就要指定inline关键字。

最后，下面的代码演示了如何在类外定义别名模板以外的成员模板：

*details/definitions3.hpp*
```cpp
template<typename T>	// a namespace scope class template
class List {
  public:
    List() = default;	// because a template constructor is defined
	
	template<typename U>	// another member class template,
	class Handle;			// without its defination
	
	template<typename U>	// a member function template
	List (List<U> const&);	// (constructor)
	
	template<typename U>	// a member variable template (since C++14)
	static U zero;
};

template<typename T>	// out-of-class member class template definition
template<typename U>
class List<T>::Handle {
  ...
};

template<typename T>	// out-of-class member function template definition
template<typenaame T2>
List<T>::List(List<T2> const& b)
{
  ...
}

template<typename T>	// out-of-class static data member template definition
template<typename U>
U List<T>::zero = 0;
```

定义在类外的成员模板需要多个`template<... >`参数化子句：每个封闭的类模板一个，成员模板本身也需要一个。子句从类模板最外层开始逐行展示。

同时也注意到构造器模板（一种特殊的成员函数模板）会禁用掉隐式声明的默认构造器（因为只有在没有其他构造器被声明时，默认构造器才会被声明）。增加一个默认的声明：

```cpp
List() = default;
```

这确保了`List<T>`的实例可以通过隐式声明的默认构造器构造出来。

**联合体模板**
联合体模板(union templates)也是可行的（它们被视为一种类模板）：

```cpp
template<typename T>
union AllocChunk {
  T object;
  unsigned char bytes[sizeof(T)];
};
```

**默认调用参数**
函数模板可以有默认参数，就如同普通的函数一样：

```cpp
template<typename T>
void report_top(Stack<T> const&, int number = 10);

template<typename T>
void fill(Array<T>&, T const& = T{});	// T{} is zero for built-in types
```

第二个声明展示了默认调用参数可以依赖于模板参数。它也可以被定义成如下形式（在C++11之前唯一可行的方式，可以参考P68节5.2）：

```cpp
template<typename T>
void fill(Array<T>&, T const& = T());	// T() is zero for built-in types
```

当`fill()`函数被调用时，如果传入了第二个参数，那么默认参数不会实例化。这保证了如果默认调用参数对特定`T`无法实例化的情景下不会发生错误。例如：

```cpp
class Value {
  public:
    explicit Value(int);	// no default constructor
};

void init(Array<Value>& array)
{
  Value zero(0);
  
  fill(array, zero);	// OK: default constructor not used
  fill(array);			// ERROR: undefined default constructor for Value is used
}
```

**类模板的非模板成员**
除了类内定义的4种基础模板以外，你还可以定义普通的类成员作为类的一部分。它们有时（错误地）也称为成员模板(member templates)。尽管它们可以被参数化，但这种定义并非头等模板。它们的参数完全由其成员的模板决定。例如：

>不太会翻译：Although they can be parameterized, such definitions aren’t quite first-class templates. 

```cpp
template<int I>
class CupBoard
{
  class Shelf;		// ordinary class in class template
  void open();		// ordinary function in class template
  enum Wood : unsigned char;		// ordinary enumeration type in class template
  static double totalWeight;		// ordinary static data member in class template
};
```

相应的定义仅仅只是为所属的类模板指定了参数化子句，但是却并没有为成员本身指定，因为其并非是一个模板（没有参数化子句与最后一个::之后出现的名称相关联）。

```cpp
template<int I>		// definition of ordinary class in class template
class CupBoard<I>::Shelf {
  ...
};

template<int I>		// definition of ordinary function in class template
void CupBoard<I>::open()
{
  ...
}

template<int I>		// definition of ordinary enumeration type class in class template
enum CupBoard<I>::Wood {
  Maple, Cherry, Oak
};

template<int I>		// definition of ordinary static member in class template
double CupBoard<I>::totalWeight = 0.0;

```

C++17之后，静态成员`totalWeight`可以在类模板内部使用`inline`关键字初始化。

```cpp
template<int I>
class CupBoard {
  ...
  inline static double totalWeight = 0.0;
};
```

尽管这种参数化定义通常被称作模板，但这里的“模板”一词相当不适用于此。对于这种情况一个被经常推荐的词是"temploid"。C++17之后，C++标准定义了模板化实体(a templated entity)的概念，它包括templates和temploids，并递归的包含模板化实体中创建或定义的任何实体（这包括，例如，一个类模板内定义的友元函数（参考P30节2.4）或是模板中出现的一个lambda表达式闭包）。不管是temploid还是templated entity目前都没有产生吸引力，但是在未来更精准的沟通C++模板时它们可能会很有用。

### 12.1.1 虚成员函数
成员函数模板不能被声明为virtual。施加这一限制是因为虚函数调用机制的通用实现会使用一个固定大小的虚表，其中存储了每一个虚函数条目（译者注：虚函数指针）。然而，成员函数模板直到整个程序被编译之前，实例化的个数都无法固定。因此，成员函数模板支持virtual需要C++编译器和链接器支持一种全新的机制。

相反的，类模板的普通成员函数可以是virtual，因为它们的数量是固定的。

```cpp
template<typename T>
class Dynamic {
  public:
    virtual ~Dynamic();	// OK: one destructor per instance of Dynamic<T>
	
	template<typename T2>
	virtual void copy(T2 const&);	// ERROR: unknown number of instances of copy()
									// given an instance of Dynamic<T>
};
```

### 12.1.2 模板的链接
每个模板都必须有一个名字，并且该名字必须是所属作用域内独一无二的，除却函数模板重载的情景（参考第16章）。特别要注意，与类类型不同，类模板无法与不同类型的实体共享名称：

```cpp
int C;
...
class C;	// OK: class names and nonclass names are in a different "space"

int X;
...
template<typename T>
class X;	// ERROR: conflict with variable X

struct S;
...
template<typename T>
class S;	// ERROR: conflict with struct S
```

模板名称具有链接，但是他们无法拥有C链接。非标准链接可能具有某个依赖于实现体的意义（然而我们并不知道某个实现体支持模板的非标准链接与否）：

```cpp
extern "C++" template<typename T>
void normal();		// this is the default: the linkage specification could be left out

extern "C" template<typename T>
void invalid();		// ERROR: templates cannot have C linkage

extern "Java" template<typename T>
void javaLink();	// nonstandard, but maybe some compiler will someday 
					// support linkage compatible with Java generics
```

模板通常有外部链接。唯一的一些例外是命名空间作用域中具有静态限定符的函数模板、匿名空间的直接或间接的成员的模板（它们拥有内部链接）以及匿名类的成员模板（它们没有链接）。

举个例子：

```cpp
template<typename T> 	// refers to the same entity as a declaration of the 
void external()			// same name (and scope) in another file

template<typename T>	// unrelated to a template with the same name in
static void internal();	// another file

template<typename T>	// redeclaration of the previous declaration
static void internal();

namespace {
  template<typename>	// also unrelated to a template with the same name
  void otherInternal();	// in another file, even one that similarly appears
}						// in an unnamed namespace

namespace {
  template<typename>	// redeclaration of the previous template declaration
  void otherInternal();
}

struct {
  template<typename T> void f(T) {} // no linkage: cannot be redeclared
} x;
```

注意到最后面的成员模板没有链接，它必须在匿名类定义处定义，因为想要在类外部定义是不可能的。

当前模板无法在函数作用域或局部类作用域中声明，但是泛化的lambda可以（参考P309节15.10.6），它有一个关联的闭包类型，其中包含了成员函数模板，其可以在局部作用域中出现，这实际上意味着一种局部成员函数模板。

模板实例的链接就是模板的链接。例如，函数`internal<void>()`从上面声明的模板`internal`实例化出来，它会拥有一个内部链接。而对于变量模板来说，这会产生一个有趣的后果。实际上，考虑下例：

```cpp
template<typename T> T zero = T{};
```

`zero`所有实例化的实例都拥有一个外部链接，即使哪怕形如`zero<int const>`也是如此。这可能对既定的拥有一个内部链接的`int const zero_int = int{};`来说是违反直觉的，毕竟它使用了一个`const`类型来做修饰。同样的，模板`template<typename T> int const max_volume = 11;`实例化的所有实例也都拥有外部链接，尽管哪些实例同样也包含类型`int const`。

### 12.1.3 主模板
模板的一般性声明声明了主模板(primary templates)。如此声明的模板在模板名后无需书写尖括号模板参数子句。

```cpp
template<typename T> class Box;		// OK: primary template
template<typename T> class Box<T>;	// ERROR: does not specialize

template<typename T> void translate(T);	// OK: primary template
template<typenaem T> void translate<T>(T);	// ERROR: not allowed for functions

template<typename T> constexpr T zero = T{};	// OK: primary template
template<typename T> constexpr T zero<T> = T{};	// ERROR: does not specialize

```

非主模板会在声明类或变量模板的偏特化时出现。这些将在第16章讨论。函数模板必须是主模板（参考P356节17.3，这里讨论了未来语言变化的某种潜在可能）。

## 12.2 模板参数
