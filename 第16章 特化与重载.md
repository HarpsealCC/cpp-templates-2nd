# 第16章 特化与重载
到目前为止，我们已经研究了C++模板如何允许将泛型定义扩展为一系列相关的类，函数或变量。尽管这是一种强大的机制，但是在许多情况下，对于模板参数的特定替换，操作的泛化形式远非最佳。

C++与其他流行的编程语言相比，对于泛型编程来说有着一独到之处，这是因为它有着一个丰富的特性集，使得某一个更加特化的设施对泛型定义进行无形替代。本章中，我们会学习两种C++语言机制，它们允许从纯粹的泛化产生实际的偏差：模板特化和函数模板重载。

## 16.1 当“泛型代码”不完全契合时
考虑下例：
```cpp
template<typename T>
class Array {
  private:
    T* data;
	...
  public:
    Array(Array<T> const&);
	Array<T>& operator=(Array<T> const&);
	
	void exchangeWith(Array<T>* b) {
	  T* tmp = data;
	  data = b->data;
	  b->data = tmp;
	}
	
	T& operator[](std::size_t k) {
	  return data[k];
	}
	...
};

template<typename T> inline
void exchange(T* a, T* b)
{
  T tmp(*a);
  *a = *b;
  *b = tmp;
}
```

对简单类型来说，`exchange()`的泛型实现表现良好。然而，对于有着昂贵的拷贝操作符的类型来说，相比于为特定的给定结构体量身定制的实现来说，泛型实现体更为昂贵（从机器周期和内存使用两方面来说）。在我们的例子中，泛型实现体需要调用一次`Array<T>`的拷贝构造器和两次`Array<T>`的拷贝操作符（译者注：作者这里应该是想用`Array<T>`代入`exchange`的模板参数`T`）。对于大尺寸的数据结构来说，这些拷贝动作通常会涉及复制相对大量的内存。然而，`exchange()`的功能可以通过仅仅交换内部的`data`指针来取而代之，就好像在其成员函数`exchangeWith()`中所作的那样。

### 16.1.1 透明的客制化
在前例中，成员函数`exchangeWith()`提供了一个对泛型`exchange()`函数的一个高效替换体，但是这样一来，就需要使用一个不同的函数，而这会在以下几个方面给我们带来不便：
1. `Array`类的使用者不得不记住其额外接口，并且必须在可以使用时万分小心。
2. 泛型算法通常无法区分不同的可能性。例如：
```cpp
template<typename T>
void genericAlgorithm(T* x, T* y)
{
  ...
  exchange(x, y);	// How do we select the right algorithm?
  ...
}
```

基于这些考虑，C++模板提供了透明地客制化函数模板和类模板的方法。对函数模板来说，是通过重载机制来达成。例如，我们可以编写一个重载的`quickExchange()`函数模板集合，如下所示：
```cpp
template<typename T>
void quickExchange(T* a, T* b)	// #1
{
  T tmp(*a);
  *a = *b;
  *b = tmp;
}

template<typename T>
void quickExchange(Array<T>* a, Array<T>* b) // #2
{
  a->exchangeWith(b);
}

void demo(Array<int>* p1, Array<int>* p2)
{
  int x = 42, y = -7;
  quickExchange(&x, &y);	// uses #1
  quickExchange(p1, p2);	// uses #2
}
```

第一个`quickExchange()`的调用有两个类型为`int*`的实参，因此只有第一个模板才能推导成功，`T`由`int`替换。因此对于哪个函数应该被调用毫无疑义。相对地，第二个调用就可以同时匹配上面的两个模板：第一个模板使用`Array<int>`替换`T`，第二个模板使用`int`替换`T`。另一方面，在两个函数替换的结果中，参数类型都是严格匹配调用实参的。通常来说，这应该得出一个调用有歧义的结论，但是相对于第一个模板来说，C++语言认为第二个模板“更加特化”。在其他项都相同的情况下，重载解析会倾向于更加特化的模板，因此这里会选择第二个函数模板。

### 16.1.2 语义透明
在上一节中使用的重载对达成实例化过程的透明客制化来说非常有用，但是有一点非常重要：该“透明性”非常非常依赖于实现体的细节。